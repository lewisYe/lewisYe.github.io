<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React | FE Knowledge</title>
    <meta name="description" content="前端知识点梳理">
    
    
    <link rel="preload" href="/assets/css/0.styles.b194f207.css" as="style"><link rel="preload" href="/assets/js/app.94b2f3ef.js" as="script"><link rel="preload" href="/assets/js/2.d467c8ee.js" as="script"><link rel="preload" href="/assets/js/7.4250d63b.js" as="script"><link rel="prefetch" href="/assets/js/10.7358a0a7.js"><link rel="prefetch" href="/assets/js/11.b76e3d06.js"><link rel="prefetch" href="/assets/js/12.a146812a.js"><link rel="prefetch" href="/assets/js/13.cf5c1852.js"><link rel="prefetch" href="/assets/js/14.c5690a9e.js"><link rel="prefetch" href="/assets/js/15.cfd708ec.js"><link rel="prefetch" href="/assets/js/16.667fb96d.js"><link rel="prefetch" href="/assets/js/17.09141bb2.js"><link rel="prefetch" href="/assets/js/18.65cc8cb4.js"><link rel="prefetch" href="/assets/js/19.742f92d8.js"><link rel="prefetch" href="/assets/js/20.93f5ef9b.js"><link rel="prefetch" href="/assets/js/21.bf458488.js"><link rel="prefetch" href="/assets/js/3.64e9b869.js"><link rel="prefetch" href="/assets/js/4.e7adceac.js"><link rel="prefetch" href="/assets/js/5.d198a837.js"><link rel="prefetch" href="/assets/js/6.eee8a3aa.js"><link rel="prefetch" href="/assets/js/8.c395ce89.js"><link rel="prefetch" href="/assets/js/9.10bd2809.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b194f207.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">FE Knowledge</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/lewisYe" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/lewisYe" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/introduction.html" class="sidebar-link">介绍</a></li><li><a href="/html.html" class="sidebar-link">HTML</a></li><li><a href="/css.html" class="sidebar-link">CSS</a></li><li><a href="/js_base.html" class="sidebar-link">JS 基础</a></li><li><a href="/js_advanced.html" class="sidebar-link">手写JS</a></li><li><a href="/es6.html" class="sidebar-link">ES6</a></li><li><a href="/browser.html" class="sidebar-link">浏览器系列</a></li><li><a href="/network.html" class="sidebar-link">网络</a></li><li><a href="/react.html" class="active sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react.html#v16-lifecycle" class="sidebar-link">V16 Lifecycle</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react.html#lifecycle-map" class="sidebar-link">Lifecycle Map</a></li><li class="sidebar-sub-header"><a href="/react.html#usage" class="sidebar-link">Usage</a></li><li class="sidebar-sub-header"><a href="/react.html#mounting" class="sidebar-link">Mounting</a></li><li class="sidebar-sub-header"><a href="/react.html#updating" class="sidebar-link">Updating</a></li><li class="sidebar-sub-header"><a href="/react.html#unmounting" class="sidebar-link">Unmounting</a></li><li class="sidebar-sub-header"><a href="/react.html#error-handling" class="sidebar-link">Error Handling</a></li><li class="sidebar-sub-header"><a href="/react.html#finally" class="sidebar-link">Finally</a></li></ul></li><li class="sidebar-sub-header"><a href="/react.html#advanced-guides" class="sidebar-link">Advanced Guides</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react.html#lazy-and-suspense" class="sidebar-link">Lazy and Suspense</a></li><li class="sidebar-sub-header"><a href="/react.html#context" class="sidebar-link">Context</a></li><li class="sidebar-sub-header"><a href="/react.html#errorboundary" class="sidebar-link">ErrorBoundary</a></li><li class="sidebar-sub-header"><a href="/react.html#fragments" class="sidebar-link">Fragments</a></li><li class="sidebar-sub-header"><a href="/react.html#react-forwardref" class="sidebar-link">React.forwardRef</a></li><li class="sidebar-sub-header"><a href="/react.html#higher-order-components" class="sidebar-link">Higher-Order Components</a></li><li class="sidebar-sub-header"><a href="/react.html#react-memo" class="sidebar-link">React.memo</a></li></ul></li><li class="sidebar-sub-header"><a href="/react.html#性能优化" class="sidebar-link">性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react.html#性能和渲染（render）正相关" class="sidebar-link">性能和渲染（Render）正相关</a></li><li class="sidebar-sub-header"><a href="/react.html#渲染（render）时影响性能的点" class="sidebar-link">渲染（Render）时影响性能的点</a></li><li class="sidebar-sub-header"><a href="/react.html#渲染（render）何时会被触发" class="sidebar-link">渲染（Render）何时会被触发</a></li><li class="sidebar-sub-header"><a href="/react.html#如何优化" class="sidebar-link">如何优化</a></li></ul></li><li class="sidebar-sub-header"><a href="/react.html#hooks" class="sidebar-link">HOOKS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react.html#hook-的产生" class="sidebar-link">Hook 的产生</a></li><li class="sidebar-sub-header"><a href="/react.html#state-hook" class="sidebar-link">State Hook</a></li><li class="sidebar-sub-header"><a href="/react.html#effect-hook" class="sidebar-link">Effect Hook</a></li><li class="sidebar-sub-header"><a href="/react.html#hook-rules" class="sidebar-link">Hook Rules</a></li><li class="sidebar-sub-header"><a href="/react.html#自定义-hook" class="sidebar-link">自定义 Hook</a></li><li class="sidebar-sub-header"><a href="/react.html#api概览" class="sidebar-link">API概览</a></li></ul></li><li class="sidebar-sub-header"><a href="/react.html#事件机制" class="sidebar-link">事件机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react.html#事件注册与存储" class="sidebar-link">事件注册与存储</a></li><li class="sidebar-sub-header"><a href="/react.html#事件分发与执行" class="sidebar-link">事件分发与执行</a></li><li class="sidebar-sub-header"><a href="/react.html#faq" class="sidebar-link">FAQ</a></li><li class="sidebar-sub-header"><a href="/react.html#react-v17中的事件" class="sidebar-link">React v17中的事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/react.html#diffing-algorithm" class="sidebar-link">Diffing Algorithm</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react.html#三个基本策略" class="sidebar-link">三个基本策略</a></li><li class="sidebar-sub-header"><a href="/react.html#同级节点diff" class="sidebar-link">同级节点Diff</a></li></ul></li><li class="sidebar-sub-header"><a href="/react.html#redux" class="sidebar-link">Redux</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react.html#三大原则" class="sidebar-link">三大原则</a></li><li class="sidebar-sub-header"><a href="/react.html#核心api" class="sidebar-link">核心API</a></li></ul></li><li class="sidebar-sub-header"><a href="/react.html#recoil" class="sidebar-link">Recoil</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react.html#核心概念" class="sidebar-link">核心概念</a></li><li class="sidebar-sub-header"><a href="/react.html#初始化" class="sidebar-link">初始化</a></li><li class="sidebar-sub-header"><a href="/react.html#订阅和更新状态" class="sidebar-link">订阅和更新状态</a></li><li class="sidebar-sub-header"><a href="/react.html#派生状态" class="sidebar-link">派生状态</a></li><li class="sidebar-sub-header"><a href="/react.html#异步状态" class="sidebar-link">异步状态</a></li></ul></li><li class="sidebar-sub-header"><a href="/react.html#requestidlecallback" class="sidebar-link">requestIdleCallback</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react.html#用法与说明" class="sidebar-link">用法与说明</a></li><li class="sidebar-sub-header"><a href="/react.html#兼容性与缺陷" class="sidebar-link">兼容性与缺陷</a></li><li class="sidebar-sub-header"><a href="/react.html#react中的polyfill版本" class="sidebar-link">React中的polyfill版本</a></li></ul></li><li class="sidebar-sub-header"><a href="/react.html#requestanimationframe" class="sidebar-link">requestAnimationFrame</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react.html#语法" class="sidebar-link">语法</a></li><li class="sidebar-sub-header"><a href="/react.html#缺陷" class="sidebar-link">缺陷</a></li></ul></li></ul></li><li><a href="/webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/ts.html" class="sidebar-link">TypeScript</a></li><li><a href="/performance.html" class="sidebar-link">性能</a></li><li><a href="/algorithm.html" class="sidebar-link">数据结构与算法</a></li><li><a href="/design.html" class="sidebar-link">设计模式</a></li><li><a href="/other.html" class="sidebar-link">其它</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react"><a href="#react" aria-hidden="true" class="header-anchor">#</a> React</h1> <p>先申明本系列基于 React 版本 16.8.6</p> <h2 id="v16-lifecycle"><a href="#v16-lifecycle" aria-hidden="true" class="header-anchor">#</a> V16 Lifecycle</h2> <h3 id="lifecycle-map"><a href="#lifecycle-map" aria-hidden="true" class="header-anchor">#</a> Lifecycle Map</h3> <p><img src="/assets/img/reactlifecycle.012efbc3.png" alt=""></p> <h3 id="usage"><a href="#usage" aria-hidden="true" class="header-anchor">#</a> Usage</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
    <span class="token comment">// 用于初始化 state</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token comment">// 用于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被调用</span>
    <span class="token comment">// 因为该函数是静态函数，所以取不到 `this` </span>
    <span class="token comment">// 如果需要对比 `prevProps` 需要单独在 `state` 中维护</span>
    <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token comment">// 判断是否需要更新组件，多用于组件性能优化</span>
    <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>


    <span class="token comment">// 组件挂载后调用</span>
    <span class="token comment">// 可以在该函数中进行请求或者订阅</span>
    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>


    <span class="token comment">// 用于获得最新的 DOM 数据</span>
    <span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    
    <span class="token comment">// 组件即将销毁</span>
    <span class="token comment">// 可以在此处移除订阅，定时器等等</span>
    <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>


    <span class="token comment">// 组件销毁后调用</span>
    <span class="token function">componentDidUnMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>


    <span class="token comment">// 组件更新后调用</span>
    <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 渲染组件函数</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>


    <span class="token comment">// 以下函数不建议使用</span>
    <span class="token function">UNSAFE_componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">UNSAFE_componentWillUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">UNSAFE_componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="mounting"><a href="#mounting" aria-hidden="true" class="header-anchor">#</a> Mounting</h3> <p>在该阶段包含生命周期函数</p> <ul><li>constructor()</li> <li>static getDerivedStateFromProps()</li> <li>render()</li> <li>componentDidMount()</li></ul> <h4 id="constructor"><a href="#constructor" aria-hidden="true" class="header-anchor">#</a> constructor()</h4> <p>构造函数的作用有两个
一个通过分配对象来初始化本地状态this.state，另一个是将事件处理程序方法绑定到实例。
在构造函数中不用使用this.setState</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Don't call this.setState() here!</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
        counter<span class="token punctuation">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="static-getderivedstatefromprops"><a href="#static-getderivedstatefromprops" aria-hidden="true" class="header-anchor">#</a> static getDerivedStateFromProps()</h4> <p><code>static getDerivedStateFromProps(props, state)</code></p> <p>getDerivedStateFromProps在调用render方法之前调用，无论是在初始安装还是后续更新。它会返回一个对象去更新状态，或者返回null不更新任何东西</p> <p>该生命周期是在16.3版本中新增的，当props或者state改变都会触发改生命周期，与这个相似的UNSAFE_componentWillReceiveProps()生命周期在之后的版本将会逐渐被替代，避免使用</p> <h4 id="render"><a href="#render" aria-hidden="true" class="header-anchor">#</a> render()</h4> <p>render()方法是类组件中唯一必需的方法。并且它是一个纯函数，意味着不会修改组件状态，每次调用时都返回相同的结果，并且它不直接与浏览器交互。
调用时它会校验this.state和this.props, 然后返回下列的几种类型的返回值</p> <ul><li>React elements</li> <li>Arrays and fragments</li> <li>Portals</li> <li>String and numbers</li> <li>Booleans or null</li></ul> <p>不能使用this.setState在该生命周期</p> <h4 id="componentdidmount"><a href="#componentdidmount" aria-hidden="true" class="header-anchor">#</a> componentDidMount()</h4> <p>在该生命周期中可以进行dom的操作和数据的网络请求</p> <h3 id="updating"><a href="#updating" aria-hidden="true" class="header-anchor">#</a> Updating</h3> <ul><li>static getDerivedStateFromProps()</li> <li>shouldComponentUpdate()</li> <li>render()</li> <li>getSnapshotBeforeUpdate()</li> <li>componentDidUpdate()</li> <li>UNSAFE_componentWillUpdate()</li> <li>UNSAFE_componentWillReceiveProps()</li></ul> <h4 id="shouldcomponentupdate"><a href="#shouldcomponentupdate" aria-hidden="true" class="header-anchor">#</a> shouldComponentUpdate()</h4> <p><code>shouldComponentUpdate(nextProps, nextState)</code></p> <p>shouldComponentUpdate 在接受到新的props和新的state的 在渲染之前会调用 默认的是返回true。该方法不会在初始的时候和使用forceUpdate()方法的时候调用。</p> <p>在该生命周期中，可以进行性能的优化。也可以使用继承PureComponent组件，该组件已经对shouldComponentUpdate做了处理但是是浅比较。例如 state中有数组和对象时，你改变state的数组和对象它可能不会更新，不会深入的比较数组和对象。此时可以引入immutable.js进行结合使用。</p> <h4 id="getsnapshotbeforeupdate"><a href="#getsnapshotbeforeupdate" aria-hidden="true" class="header-anchor">#</a> getSnapshotBeforeUpdate()</h4> <p><code>getSnapshotBeforeUpdate(prevProps, prevState)</code></p> <p>在该生命周期中 state 已经更新，可以进行一些dom 操作，在render更新之前</p> <h4 id="componentdidupdate"><a href="#componentdidupdate" aria-hidden="true" class="header-anchor">#</a> componentDidUpdate()</h4> <p><code>componentDidUpdate(prevProps, prevState, snapshot)</code></p> <p>componentDidUpdate()更新发生后立即调用。初始渲染不会调用此方法。
该生命周期你也可以去操作dom，或者进行网络请求，当你发现props改变时。但是不能使用直接setState那样会导致无限循环，你可以再某种判断条件下使用。
如果组件使用了 getSnapshotBeforeUpdate()生命周期，则它返回的值将作为第三个“快照”参数传递给componentDidUpdate()。否则此参数将是未定义的。</p> <h4 id="unsafe-componentwillupdate"><a href="#unsafe-componentwillupdate" aria-hidden="true" class="header-anchor">#</a> UNSAFE_componentWillUpdate()</h4> <p><code>UNSAFE_componentWillUpdate(nextProps, nextState)</code></p> <p>此生命周期之前已命名componentWillUpdate。该名称将继续有效，直到版本17. 使用rename-unsafe-lifecyclescodemod自动更新组件。
UNSAFE_componentWillUpdate()在收到新的props或state时，在渲染之前调用。使用此作为在更新发生之前执行准备的机会。初始渲染不会调用此方法
不能再此使用this.setState</p> <h4 id="unsafe-componentwillreceiveprops"><a href="#unsafe-componentwillreceiveprops" aria-hidden="true" class="header-anchor">#</a> UNSAFE_componentWillReceiveProps()</h4> <p><code>UNSAFE_componentWillReceiveProps(nextProps)</code></p> <p>此生命周期之前已命名componentWillReceiveProps。该名称将继续有效，直到版本17. 使用rename-unsafe-lifecyclescodemod自动更新组件。</p> <p>该生命周期在初始化的时候不会被调用，只有当props被改变的时候会被调用, this.setState不会触发它</p> <h3 id="unmounting"><a href="#unmounting" aria-hidden="true" class="header-anchor">#</a> Unmounting</h3> <ul><li>componentWillUnmount()</li></ul> <h4 id="componentwillunmount"><a href="#componentwillunmount" aria-hidden="true" class="header-anchor">#</a> componentWillUnmount()</h4> <p>componentWillUnmount()在卸载和销毁组件之前立即调用。在此方法中执行任何必要的清理，例如使计时器无效，取消网络请求或清除在componentDidMount()其中创建的任何订阅。</p> <p>不能调用setState()，componentWillUnmount()因为组件永远不会被重新呈现。卸载组件实例后，将永远不会再次mount它。</p> <h3 id="error-handling"><a href="#error-handling" aria-hidden="true" class="header-anchor">#</a> Error Handling</h3> <ul><li>static getDerivedStateFromError()</li> <li>componentDidCatch()</li></ul> <h4 id="static-getderivedstatefromerror"><a href="#static-getderivedstatefromerror" aria-hidden="true" class="header-anchor">#</a> static getDerivedStateFromError()</h4> <p><code>static getDerivedStateFromError(error)</code></p> <p>在子组件抛出错误后会调用此生命周期。它接收作为参数抛出的错误，并返回值以更新状态。
在组件 “render” 阶段的时候就会被调用，不允许副作用</p> <h4 id="componentdidcatch"><a href="#componentdidcatch" aria-hidden="true" class="header-anchor">#</a> componentDidCatch()</h4> <p><code>componentDidCatch(error, info)</code></p> <p>在子组件抛出错误的时候回调用此生命周期，它有2个参数，一个是错误，还有一个是对象，key对应的是错误来自哪个子组件。
该生命周期在 “ commit” 阶段调用所以可以有副作用</p> <h3 id="finally"><a href="#finally" aria-hidden="true" class="header-anchor">#</a> Finally</h3> <h4 id="_16-版本新增的生命周期"><a href="#_16-版本新增的生命周期" aria-hidden="true" class="header-anchor">#</a> 16 版本新增的生命周期</h4> <ul><li>static getDerivedStateFromProps()</li> <li>getSnapshotBeforeUpdate()</li> <li>static getDerivedStateFromError()</li> <li>componentDidCatch()</li></ul> <h4 id="_16-版本废除和减少使用的生命周期"><a href="#_16-版本废除和减少使用的生命周期" aria-hidden="true" class="header-anchor">#</a> 16 版本废除和减少使用的生命周期</h4> <ul><li>UNSAFE_componentWillUpdate()</li> <li>UNSAFE_componentWillReceiveProps()</li> <li>UNSAFE_componentWillMount()</li></ul> <h4 id="this-setstate-不能调用的生命周期"><a href="#this-setstate-不能调用的生命周期" aria-hidden="true" class="header-anchor">#</a> this.setState 不能调用的生命周期</h4> <ul><li>constructor()</li> <li>render()</li> <li>componentDidUpdate() 不能直接使用</li> <li>UNSAFE_componentWillUpdate()</li> <li>UNSAFE_componentWillMount()</li></ul> <h2 id="advanced-guides"><a href="#advanced-guides" aria-hidden="true" class="header-anchor">#</a> Advanced Guides</h2> <h3 id="lazy-and-suspense"><a href="#lazy-and-suspense" aria-hidden="true" class="header-anchor">#</a> Lazy and Suspense</h3> <p>React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise，该 Promise 需要 resolve 一个 default export 的 React 组件。</p> <p>然后应在 Suspense 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优雅降级（如 loading 指示器等）。</p> <p>React.lazy 目前只支持默认导出（default exports）</p> <p>示例：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Suspense <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> OtherComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./OtherComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Suspense fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>Loading<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>OtherComponent <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>Suspense<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>fallback 属性接受任何在组件加载过程中你想展示的 React 元素。你可以将 Suspense 组件置于懒加载组件之上的任何位置。你甚至可以用一个 Suspense 组件包裹多个懒加载组件。</p> <p><strong>总结：使用该组方法可以实现代码的动态加载 更好的进行代码分割</strong></p> <h3 id="context"><a href="#context" aria-hidden="true" class="header-anchor">#</a> Context</h3> <p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p> <h4 id="context使用场景"><a href="#context使用场景" aria-hidden="true" class="header-anchor">#</a> Context使用场景</h4> <p>当一个父组件需要给子组件传递一个props时，但是嵌套层数比较多时，比如4-5层，那去维护这个props就显得复杂。那么就可以使用context来共享这些数据。</p> <h4 id="如何使用"><a href="#如何使用" aria-hidden="true" class="header-anchor">#</a> 如何使用</h4> <p>API</p> <ul><li>React.createContext</li> <li>Context.Provider</li> <li>Class.contextType</li> <li>Context.Consumer</li> <li>Context.displayName</li></ul> <p><strong>React.createContext</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> MyContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span>defaultValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。</p> <p>只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。</p> <p>注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效。</p> <p><strong>Context. Provider</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span>MyContext<span class="token punctuation">.</span>Provider value <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token comment">/* 某个值 */</span> <span class="token punctuation">}</span> <span class="token operator">&gt;</span>
</code></pre></div><p>Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。</p> <p>当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。</p> <p>通过新旧值检测来确定变化，使用了与 Object.is 相同的算法。</p> <p><strong>Class.contextType</strong></p> <p>挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> contextType <span class="token operator">=</span> MyContext <span class="token comment">// 该写法需要安装babel插件转义</span>
    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">;</span>
        <span class="token comment">/* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */</span>
    <span class="token punctuation">}</span>
    <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">;</span>
        <span class="token comment">/* ... */</span>
    <span class="token punctuation">}</span>
    <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">;</span>
        <span class="token comment">/* ... */</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">;</span>
        <span class="token comment">/* 基于 MyContext 组件的值进行渲染 */</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
MyClass<span class="token punctuation">.</span>contextType <span class="token operator">=</span> MyContext<span class="token punctuation">;</span>
</code></pre></div><p><strong>Context.Consumer</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span>MyContext<span class="token punctuation">.</span>Consumer<span class="token operator">&gt;</span>
  <span class="token punctuation">{</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token comment">/* 基于 context 值进行渲染*/</span><span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>MyContext<span class="token punctuation">.</span>Consumer<span class="token operator">&gt;</span>
</code></pre></div><p>这需要函数作为子元素（function as a child）这种做法。这个函数接收当前的 context 值，返回一个 React 节点。传递给函数的 value 值等同于往上组件树离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。</p> <p><strong>Context.displayName</strong></p> <p>context 对象接受一个名为 displayName 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> MyContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token comment">/* some value */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
MyContext<span class="token punctuation">.</span>displayName <span class="token operator">=</span> <span class="token string">'MyDisplayName'</span><span class="token punctuation">;</span>

<span class="token operator">&lt;</span>MyContext<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span> <span class="token comment">// &quot;MyDisplayName.Provider&quot; 在 DevTools 中</span>
<span class="token operator">&lt;</span>MyContext<span class="token punctuation">.</span>Consumer<span class="token operator">&gt;</span> <span class="token comment">// &quot;MyDisplayName.Consumer&quot; 在 DevTools 中</span>
</code></pre></div><p>组合使用例子</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。</span>
<span class="token comment">// 为当前的 theme 创建一个 context（“light”为默认值）。</span>
<span class="token keyword">const</span> ThemeContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">'light'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span>
    <span class="token comment">// 无论多深，任何组件都能读取这个值。</span>
    <span class="token comment">// 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>ThemeContext<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token string">&quot;dark&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>Toolbar <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ThemeContext<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 中间的组件再也不必指明往下传递 theme 了。</span>
<span class="token keyword">function</span> <span class="token function">Toolbar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ThemedButton <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ThemedButton</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token comment">// 指定 contextType 读取当前的 theme context。</span>
  <span class="token comment">// React 会往上找到最近的 theme Provider，然后使用它的值。</span>
  <span class="token comment">// 在这个例子中，当前的 theme 值为 “dark”。</span>
  <span class="token keyword">static</span> contextType <span class="token operator">=</span> ThemeContext<span class="token punctuation">;</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>Button theme<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="errorboundary"><a href="#errorboundary" aria-hidden="true" class="header-anchor">#</a> ErrorBoundary</h3> <p>错误边界是一种 React 组件，这种组件<strong>可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI</strong>，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。</p> <p>注意事项:</p> <p>错误边界无法捕获以下场景中产生的错误：</p> <ul><li>事件处理</li> <li>异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）</li> <li>服务端渲染</li> <li>它自身抛出来的错误（并非它的子组件）</li></ul> <h4 id="形成条件"><a href="#形成条件" aria-hidden="true" class="header-anchor">#</a> 形成条件</h4> <p>如果一个 class 组件中定义了 <code>static getDerivedStateFromError()</code> 或 <code>componentDidCatch()</code> 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 <code>static getDerivedStateFromError()</code> 渲染备用 UI ，使用 <code>componentDidCatch()</code> 打印错误信息。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">ErrorBoundary</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> hasError<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromError</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> hasError<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentDidCatch</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> errorInfo</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 你同样可以将错误日志上报给服务器</span>
    <span class="token function">logErrorToMyService</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> errorInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>hasError<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 你可以自定义降级后的 UI 并渲染</span>
      <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Something went wrong<span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="fragments"><a href="#fragments" aria-hidden="true" class="header-anchor">#</a> Fragments</h3> <p>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。</p> <p>用法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>React<span class="token punctuation">.</span>Fragment<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ChildA <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ChildB <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ChildC <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>React<span class="token punctuation">.</span>Fragment<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//或者短语法</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ChildA <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ChildB <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ChildC <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>使用显式 <code>&lt;React.Fragment&gt;</code>语法声明的片段可能具有 key ;短语法不支持key.</p> <h3 id="react-forwardref"><a href="#react-forwardref" aria-hidden="true" class="header-anchor">#</a> React.forwardRef</h3> <p>Ref forwarding 是一项将 ref 自动地通过组件传递到其一子组件的技巧。</p> <p>为什么会有这个功能呢 因为refs 不会被props透传下去。这是因为 ref 不是 prop 属性。就像 key 一样，其被 React 进行了特殊处理。</p> <p>用法：React.forwardRef 接受一个渲染函数，其接收 props 和 ref 参数并返回一个 React 节点。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">logProps</span><span class="token punctuation">(</span><span class="token parameter">Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">LogProps</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
    <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'old props:'</span><span class="token punctuation">,</span> prevProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'new props:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span>forwardedRef<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>
      <span class="token comment">// 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span>
      <span class="token keyword">return</span> <span class="token operator">&lt;</span>Component ref<span class="token operator">=</span><span class="token punctuation">{</span>forwardedRef<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span>rest<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 注意 React.forwardRef 回调的第二个参数 “ref”。</span>
  <span class="token comment">// 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span>
  <span class="token comment">// 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span>
  <span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>LogProps <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> forwardedRef<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该方法常用于高阶函数。</p> <h3 id="higher-order-components"><a href="#higher-order-components" aria-hidden="true" class="header-anchor">#</a> Higher-Order Components</h3> <p>高阶组件（HOC）是React中一个复用组件逻辑的高级技术。简单的说，就是获取一个组件返回一个新的组件。常见的如Redux的connect方法等。 它是一个纯函数，没有副作用</p> <p>用法</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">logProps</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
    <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Current props: '</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Previous props: '</span><span class="token punctuation">,</span> prevProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent <span class="token punctuation">{</span><span class="token operator">...</span>this<span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意点:</p> <ul><li>HOC 应该透传与自身无关的 props</li> <li>HOC创建的容器在调试的时候会显示一样的名字 可以用displayname 来处理</li> <li>不能在render中使用HOC</li> <li>静态方法必须复制 higherOrderComponent.staticMethod = WrappedComponent.staticMethod;</li> <li>Refs 不会被传递 可以只用React.forwardRef解决</li></ul> <h3 id="react-memo"><a href="#react-memo" aria-hidden="true" class="header-anchor">#</a> React.memo</h3> <p>React.memo 为高阶组件。它与 React.PureComponent 非常相似，但只适用于函数组件，而不适用 class 组件。</p> <p>如果你的函数组件在给定相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p> <p>React.memo 仅检查 props 变更。如果函数组件被 React.memo 包裹，且其实现中拥有 useState 或 useContext 的 Hook，当 context 发生变化时，它仍会重新渲染。</p> <p>默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p> <p>用法</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 使用 props 渲染 */</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">areEqual</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*
  如果把 nextProps 传入 render 方法的返回结果与
  将 prevProps 传入 render 方法的返回结果一致则返回 true，
  否则返回 false
  */</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">,</span> areEqual<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="性能优化"><a href="#性能优化" aria-hidden="true" class="header-anchor">#</a> 性能优化</h2> <h3 id="性能和渲染（render）正相关"><a href="#性能和渲染（render）正相关" aria-hidden="true" class="header-anchor">#</a> 性能和渲染（Render）正相关</h3> <p>React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。</p> <h3 id="渲染（render）时影响性能的点"><a href="#渲染（render）时影响性能的点" aria-hidden="true" class="header-anchor">#</a> 渲染（Render）时影响性能的点</h3> <p>React 处理 render 的基本思维模式是每次一有变动就会去重新渲染整个应用。Virtual DOM 厉害的地方并不是说它比直接操作 DOM 快，而是说不管数据怎么变，都会尽量以最小的代价去更新 DOM。React 将 render 函数返回的虚拟 DOM 树与老的进行比较，从而确定 DOM 要不要更新、怎么更新。当 DOM 树很大时，遍历两棵树进行各种比对还是相当耗性能的，特别是在顶层 setState 一个微小的修改，默认会去遍历整棵树。尽管 React 使用高度优化的 Diff 算法 ，但是这个过程仍然会损耗性能。</p> <h3 id="渲染（render）何时会被触发"><a href="#渲染（render）何时会被触发" aria-hidden="true" class="header-anchor">#</a> 渲染（Render）何时会被触发</h3> <p>触发render的条件有：</p> <ul><li><p>组件挂载</p> <p>React 组件构建并将 DOM 元素插入页面的过程称为挂载。当组件首次渲染的时候会调用 render，这个过程不可避免。</p></li> <li><p>setState 方法的调用</p> <p>通常情况下，执行 setState 会触发 render。但当 setState 传入 null 的时候，并不会触发 render 。</p></li> <li><p>父组件重新渲染</p> <p>只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render。</p></li></ul> <h3 id="如何优化"><a href="#如何优化" aria-hidden="true" class="header-anchor">#</a> 如何优化</h3> <p>根本思路减少不必要的render。</p> <p>根据类组件和函数组件的不同具体有不同的方法。</p> <p><strong>类组件的性能优化</strong></p> <h4 id="shouldcomponentupdate-和-purecomponent"><a href="#shouldcomponentupdate-和-purecomponent" aria-hidden="true" class="header-anchor">#</a> shouldComponentUpdate 和 PureComponent</h4> <p>在React类组件中，可以利用<code>shouldComponentUpdate</code> 或者 <code>PureComponent</code> 来减少因父组件更新而触发子组件的render。</p> <p><code>shouldComponentUpdate</code> 生命周期，可以通过返回true代表需要重新渲染，返回false代表不渲染</p> <p><code>PureComponent</code> 通过对props和state的<strong>浅比较</strong>结果来实现<code>shouldComponentUpdate</code>,但是当对象包含复杂的数据结构时，可能就不灵啦，对象深层的数据改变但是没有触发render。</p> <p>在React中<code>PureComponent</code>源码如下</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_compositeType <span class="token operator">===</span> CompositeTypes<span class="token punctuation">.</span>PureClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  shouldUpdate <span class="token operator">=</span> <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> nextProps<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span> <span class="token function">shallowEqual</span><span class="token punctuation">(</span>inst<span class="token punctuation">.</span>state<span class="token punctuation">,</span> nextState<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>shallowEqual</code>的实现代码</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> hasOwnProperty <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>hasOwnProperty<span class="token punctuation">;</span>

<span class="token comment">/**
 * is 方法来判断两个值是否是相等的值，为何这么写可以移步 MDN 的文档
 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */</span>
<span class="token keyword">function</span> <span class="token function">is</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> mixed<span class="token punctuation">,</span> y<span class="token punctuation">:</span> mixed</span><span class="token punctuation">)</span><span class="token punctuation">:</span> boolean <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">!==</span> <span class="token number">0</span> <span class="token operator">||</span> y <span class="token operator">!==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token number">1</span> <span class="token operator">/</span> x <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">/</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">!==</span> x <span class="token operator">&amp;&amp;</span> y <span class="token operator">!==</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">shallowEqual</span><span class="token punctuation">(</span><span class="token parameter">objA<span class="token punctuation">:</span> mixed<span class="token punctuation">,</span> objB<span class="token punctuation">:</span> mixed</span><span class="token punctuation">)</span><span class="token punctuation">:</span> boolean <span class="token punctuation">{</span>
  <span class="token comment">// 首先对基本类型进行比较</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is</span><span class="token punctuation">(</span>objA<span class="token punctuation">,</span> objB<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> objA <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> objA <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span>
      <span class="token keyword">typeof</span> objB <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> objB <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> keysA <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>objA<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> keysB <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>objB<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 长度不相等直接返回false</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>keysA<span class="token punctuation">.</span>length <span class="token operator">!==</span> keysB<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// key相等的情况下，再去循环比较</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keysA<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      <span class="token operator">!</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>objB<span class="token punctuation">,</span> keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span>
      <span class="token operator">!</span><span class="token function">is</span><span class="token punctuation">(</span>objA<span class="token punctuation">[</span>keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> objB<span class="token punctuation">[</span>keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="高阶组件"><a href="#高阶组件" aria-hidden="true" class="header-anchor">#</a> 高阶组件</h4> <p>在函数组件中，并没有<code>shouldComponnetUpdate</code>这个生命周期，但是可以利用高阶组件来实现一个类型的功能。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">shouldComponentUpdate</span> <span class="token operator">=</span> <span class="token parameter">areEqual</span> <span class="token operator">=&gt;</span> <span class="token parameter">BaseComponent</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">ShouldComponentUpdate</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span>
        <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">areEqual</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">,</span>nextProps<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">&lt;</span>BaseComponent <span class="token punctuation">{</span><span class="token operator">...</span>this<span class="token punctuation">.</span>props<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    ShouldComponentUpdate<span class="token punctuation">.</span>displayName <span class="token operator">=</span> <span class="token template-string"><span class="token string">`Pure(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>BaseComponent<span class="token punctuation">.</span>displayName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
    <span class="token keyword">return</span> ShouldComponentUpdate
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">Pure</span> <span class="token operator">=</span> <span class="token parameter">BaseComponent</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> hoc <span class="token operator">=</span> <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span>
  	<span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> nextProps</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> nextProps<span class="token punctuation">)</span>
  <span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token function">hoc</span><span class="token punctuation">(</span>BaseComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用<code>Pure</code>高阶组件时，只需要对我们子组件进行装饰即可</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React <span class="token keyword">from</span><span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">Child</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">Pure</span><span class="token punctuation">(</span>Child<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>函数组件</strong>
用例子来说明具体的用法，有如下一个场景：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// parent.js</span>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>title<span class="token punctuation">,</span>setTitle<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'ye'</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span><span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">&quot;ye1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>更改名称<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>Child name<span class="token operator">=</span><span class="token string">&quot;lewisye&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// child.js</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;child&quot;</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> Child
</code></pre></div><p>当parent组件初次渲染的时候，控制台会打印出child字符串，这表示子组件也渲染了。但是当你点击去更改名称按钮时，控制台有一次打印了。但是这种情况是我们不想看到的。因为你传入给child的props并没有改变，这需要减少子组件的重新渲染来提高性能。那我们可以用到的就是React.memo</p> <h4 id="react-memo-2"><a href="#react-memo-2" aria-hidden="true" class="header-anchor">#</a> React.memo</h4> <p>React.memo 为高阶组件。它与 React.PureComponent 非常相似，但只适用于函数组件，而不适用 class 组件。</p> <p>默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 使用 props 渲染 */</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">areEqual</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*
  如果把 nextProps 传入 render 方法的返回结果与
  将 prevProps 传入 render 方法的返回结果一致则返回 true，
  否则返回 false
  */</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">,</span> areEqual<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>注意</strong></p> <p>与 class 组件中 shouldComponentUpdate() 方法不同的是，如果 props 相等，areEqual 会返回 true；如果 props 不相等，则返回 false。这与 shouldComponentUpdate 方法的返回值相反。</p> <p>那具体怎么使用呢，其实只需要讲child组件用React.memo包裹起来就可以.</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;child&quot;</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>Child<span class="token punctuation">)</span>
</code></pre></div><h4 id="usecallback"><a href="#usecallback" aria-hidden="true" class="header-anchor">#</a> useCallback</h4> <p>我们将上述的例子改变一下，当改变标题的方法在子组件触发,并再添加一个触发事件</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// parent.js</span>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>title<span class="token punctuation">,</span>setTitle<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'ye'</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> <span class="token function-variable function">print</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'print'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">&quot;ye1&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span><span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>print<span class="token punctuation">}</span><span class="token operator">&gt;</span>输出<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Child name<span class="token operator">=</span><span class="token string">&quot;lewisye&quot;</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span>callback<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// child.js</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;child&quot;</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span><span class="token punctuation">(</span>
    <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>onClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>改标题<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>Child<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>首次渲染你可以看到打印了child字符，当点击输出按钮的时候，你会发现再一次打印了字符串。这是为什么呢，我们之前不是用React.memo处理了吗。</p> <p>分析一下，一个组件重新重新渲染，一般三种情况：</p> <ul><li><p>要么是组件自己的状态改变</p></li> <li><p>要么是父组件重新渲染，导致子组件重新渲染，但是父组件的 props 没有改变</p></li> <li><p>要么是父组件重新渲染，导致子组件重新渲染，但是父组件传递的 props 改变</p></li></ul> <p>显然现在符合我们场景的只有第三种，第一种在该例子中没有用到，第二种我们上门已经用React.memo处理了。那是哪个props改变了呢，一个是name一个是onClick函数方法，显然是oClick函数方法。</p> <p>在函数式组件里每次重新渲染，函数组件都会重头开始重新执行,那么onClick方法就变得不同啦。那如何解决呢，当然需要我们的useCallback</p> <p>useCallback 的使用语法</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> memoizedCallback <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">doSomething</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>返回一个 memoized 回调函数。</p> <p>把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新</p> <p>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)</p> <p>那怎么在例子使用呢？  /通过 useCallback 进行记忆 callback，并将记忆的 callback 传递给 Child
const memoizedCallback = useCallback(callback, [])</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// parent.js</span>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>title<span class="token punctuation">,</span>setTitle<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'ye'</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> <span class="token function-variable function">print</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'print'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">&quot;ye1&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> memoizedCallback <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span><span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>print<span class="token punctuation">}</span><span class="token operator">&gt;</span>输出<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Child name<span class="token operator">=</span><span class="token string">&quot;lewisye&quot;</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span>memoizedCallback<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="usememo"><a href="#usememo" aria-hidden="true" class="header-anchor">#</a> useMemo</h4> <p>React 的性能优化方向主要是两个：一个是减少重新 render 的次数(或者说减少不必要的渲染)，另一个是减少计算的量。</p> <p>上述介绍的 React.memo 和 useCallback 都是为了减少重新 render 的次数。对于如何减少计算的量，就是 useMemo 来做的，接下来我们看例子。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> setNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 一个非常耗时的一个计算函数</span>
  <span class="token comment">// result 最后返回的值是 49995000</span>
  <span class="token keyword">function</span> <span class="token function">expensiveFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">// 49995000</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> base <span class="token operator">=</span> <span class="token function">expensiveFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>count：<span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setNum</span><span class="token punctuation">(</span>num <span class="token operator">+</span> base<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个例子功能很简单，就是点击 +1 按钮，然后会将现在的值(num) 与 计算函数 (expensiveFn) 调用后的值相加，然后将和设置给 num 并显示出来，在控制台会输出 49995000。</p> <p>先我们把 expensiveFn 函数当做一个计算量很大的函数(比如你可以把 i 换成 10000000)，然后当我们每次点击 +1 按钮的时候，都会重新渲染组件，而且都会调用 expensiveFn 函数并输出 49995000。由于每次调用 expensiveFn 所返回的值都一样，所以我们可以想办法将计算出来的值缓存起来，每次调用函数直接返回缓存的值，这样就可以做一些性能优化。</p> <p>针对上面产生的问题，就可以用 useMemo 来缓存 expensiveFn 函数执行后的值。</p> <p>useMemo基本用法</p> <p><code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b])</code></p> <p>返回一个 memoized 值。</p> <p>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算</p> <p>记住，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。</p> <p>如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值</p> <p>在例子中使用优化后的代码：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> setNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">expensiveFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> base <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span>expensiveFn<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;App&quot;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>count：<span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setNum</span><span class="token punctuation">(</span>num <span class="token operator">+</span> base<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>执行上面的代码，然后现在可以观察无论我们点击 +1多少次，只会输出一次 49995000，这就代表 expensiveFn 只执行了一次，达到了我们想要的效果。</p> <h4 id="合理拆分组件"><a href="#合理拆分组件" aria-hidden="true" class="header-anchor">#</a> 合理拆分组件</h4> <p>试想当整个页面只有一个组件时，无论哪处改动都会触发render，那么对于组件进行拆分，颗粒度更细，render就可以得到更细的控制，性能也有一定的提升</p> <h2 id="hooks"><a href="#hooks" aria-hidden="true" class="header-anchor">#</a> HOOKS</h2> <p>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。</p> <h3 id="hook-的产生"><a href="#hook-的产生" aria-hidden="true" class="header-anchor">#</a> Hook 的产生</h3> <p>Hook的产生为了解决什么问题 或者 带来了什么便利呢？</p> <h4 id="hook-使你在无需修改组件结构的情况下复用状态逻辑"><a href="#hook-使你在无需修改组件结构的情况下复用状态逻辑" aria-hidden="true" class="header-anchor">#</a> Hook 使你在无需修改组件结构的情况下复用状态逻辑</h4> <p>在React 中 复用状态逻辑很难，常用的方法有 高阶组件 和 render props 。但是这些方法需要你重新组织你的组件结构，使得代码难以理解。</p> <h4 id="hook-将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）"><a href="#hook-将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）" aria-hidden="true" class="header-anchor">#</a> Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</h4> <p>组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。</p> <h4 id="hook-使你在非-class-的情况下可以使用更多的-react-特性"><a href="#hook-使你在非-class-的情况下可以使用更多的-react-特性" aria-hidden="true" class="header-anchor">#</a> Hook 使你在非 class 的情况下可以使用更多的 React 特性</h4> <p>在使用class 你需要理解js中的this机制</p> <p>参考链接：<a href="https://zhuanlan.zhihu.com/p/137183261" target="_blank" rel="noopener noreferrer">React为什么需要Hook<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="state-hook"><a href="#state-hook" aria-hidden="true" class="header-anchor">#</a> State Hook</h3> <p><code>useState</code>是React内置的一个Hook，以它为例实现一个计数器:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 声明一个叫 &quot;count&quot; 的 state 变量</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>You clicked <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
        Click me
      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>useState</code>方法定义了一个 state 变量，变量名叫做count。</p> <p><code>useState</code>方法有一个唯一的参数，代表是变量的初始化，可以是数字、字符、对象等类型</p> <p><code>useState</code>方法的返回值为 当前 state 以及更新 state 的函数</p> <p><strong>在一个函数组件中也可以声明多个state变量</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">ExampleWithManyStates</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 声明多个 state 变量！</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>age<span class="token punctuation">,</span> setAge<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>fruit<span class="token punctuation">,</span> setFruit<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'banana'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>todos<span class="token punctuation">,</span> setTodos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span> text<span class="token punctuation">:</span> <span class="token string">'Learn Hooks'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="effect-hook"><a href="#effect-hook" aria-hidden="true" class="header-anchor">#</a> Effect Hook</h3> <p>Effect Hook 可以让你在函数组件中执行副作用操作。数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。</p> <p>我们为计数器增加了一个小功能：将 document 的 title 设置为包含了点击次数的消息。使用到useEffect：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 类似于 componentDidMount and componentDidUpdate:</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token template-string"><span class="token string">`You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>You clicked <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
        Click me
      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过使用这个 useEffect Hook，你可以告诉 React 组件需要在渲染后执行某些操作。React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。</p> <p>在 React 组件中有两种常见副作用操作：需要清除的和不需要清除的。effect Hook 使用同一个 API 来满足这两种情况。通过在函数中 返回一个函数来处理。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 清除</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>使用多个 Effect 实现关注点分离</strong></p> <p>Hook 允许我们按照代码的用途分离他们， 而不是像生命周期函数那样。React 将按照 effect 声明的顺序依次调用组件中的每一个 effect。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">FriendStatusWithCounter</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token template-string"><span class="token string">`You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token punctuation">[</span>isOnline<span class="token punctuation">,</span> setIsOnline<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">handleStatusChange</span><span class="token punctuation">(</span><span class="token parameter">status</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setIsOnline</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span>isOnline<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    ChatAPI<span class="token punctuation">.</span><span class="token function">subscribeToFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      ChatAPI<span class="token punctuation">.</span><span class="token function">unsubscribeFromFriendStatus</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">,</span> handleStatusChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>为什么每次更新的时候都要运行 Effect</strong></p> <p>当组件已经显示在屏幕上时，prop 发生变化时会发生什么？ 我们的组件将继续展示原来状态 这是一个 bug。在class写法中需要在componentDidUpdate生命周期中处理。但是effect 并不需要特定的代码来处理更新逻辑，因为 useEffect 默认就会处理。它会在调用一个新的 effect 之前对前一个 effect 进行清理</p> <p><strong>通过跳过 Effect 进行性能优化</strong></p> <p>在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。在 class 组件中，我们可以通过在 componentDidUpdate 中添加对 prevProps 或 prevState 的比较逻辑解决。</p> <p>所以它被内置到了 useEffect 的 Hook API 中。如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token template-string"><span class="token string">`You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 仅在 count 更改时更新</span>
</code></pre></div><p>如果你要使用此优化方式，请确保数组中包含了所有外部作用域中会随时间变化并且在 effect 中使用的变量，否则你的代码会引用到先前渲染中的旧变量</p> <p>如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。</p> <h3 id="hook-rules"><a href="#hook-rules" aria-hidden="true" class="header-anchor">#</a> Hook Rules</h3> <p>Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则</p> <ul><li>只在最顶层使用 Hook</li> <li>只在 React 函数中调用 Hook</li></ul> <h4 id="只在最顶层使用-hook"><a href="#只在最顶层使用-hook" aria-hidden="true" class="header-anchor">#</a> 只在最顶层使用 Hook</h4> <p><strong>不要在循环，条件或嵌套函数中调用 Hook</strong>， 确保总是在你的 React 函数的最顶层调用他们</p> <p>遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确</p> <p>如果我们想要有条件地执行一个 effect，可以将判断放到 Hook 的内部</p> <h4 id="只在-react-函数中调用-hook"><a href="#只在-react-函数中调用-hook" aria-hidden="true" class="header-anchor">#</a> 只在 React 函数中调用 Hook</h4> <p><strong>不要在普通的 JavaScript 函数中调用 Hook</strong></p> <p>你可以：</p> <ul><li>✅ 在 React 的函数组件中调用 Hook</li> <li>✅ 在自定义 Hook 中调用其他 Hook</li></ul> <h3 id="自定义-hook"><a href="#自定义-hook" aria-hidden="true" class="header-anchor">#</a> 自定义 Hook</h3> <p>自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。</p> <p>自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。在两个组件中使用相同的 Hook 不会共享 state。</p> <p>自定义 Hook 解决了以前在 React 组件中无法灵活共享逻辑的问题</p> <h3 id="api概览"><a href="#api概览" aria-hidden="true" class="header-anchor">#</a> API概览</h3> <ul><li>基础Hook
<ul><li>useState</li> <li>useEffect</li> <li>useContext</li></ul></li> <li>额外的Hook
<ul><li>useReducer</li> <li>useCallback</li> <li>useMemo</li> <li>useRef</li> <li>useImperativeHandle</li> <li>useLayoutEffect</li> <li>useDebugValue</li></ul></li></ul> <h4 id="usestate"><a href="#usestate" aria-hidden="true" class="header-anchor">#</a> useState</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span>setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>initialState<span class="token punctuation">)</span>
</code></pre></div><p>返回一个state，以及更新state的函数</p> <p>在初始渲染期间，返回的状态 (state) 与传入的第一个参数 (initialState) 值相同。</p> <p>setState 函数用于更新 state。它接收一个新的 state 值并将组件的一次重新渲染加入队列。<code>setState(newState)</code></p> <p>在后续的重新渲染中，useState 返回的第一个值将始终是更新后最新的 state。</p> <p><strong>函数式更新</strong></p> <p>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">setState</span><span class="token punctuation">(</span><span class="token parameter">pervState</span> <span class="token operator">=&gt;</span> pervState <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p>如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过。</p> <p>与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">setState</span><span class="token punctuation">(</span><span class="token parameter">prevState</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 也可以使用 Object.assign</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token operator">...</span>prevState<span class="token punctuation">,</span> <span class="token operator">...</span>updatedValues<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>惰性初始state</strong></p> <p>如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> initialState <span class="token operator">=</span> <span class="token function">someExpensiveComputation</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> initialState<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="useeffect"><a href="#useeffect" aria-hidden="true" class="header-anchor">#</a> useEffect</h4> <p><code>useEffect(didUpdate)</code></p> <p>该Hook接收一个包含命令式、且可能有副作用代码的函数</p> <p>使用 useEffect 完成副作用操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。</p> <p><strong>清除effect</strong></p> <p>通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。要实现这一点，useEffect 函数需返回一个清除函数。以下就是一个创建订阅的例子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> subscription <span class="token operator">=</span> props<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token comment">//清除订阅</span>
    subscription<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除。</p> <p><strong>effect的条件执行</strong></p> <p>默认情况下，effect 会在每轮组件渲染完成后执行。这样的话，一旦 effect 的依赖发生变化，它就会被重新创建。但某些场景并不需要每次组件更新时，被执行。</p> <p>要实现这一点，可以给 useEffect 传递第二个参数，它是 effect 所依赖的值数组。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">useEffect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> subscription <span class="token operator">=</span> props<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
      subscription<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>props<span class="token punctuation">.</span>source<span class="token punctuation">]</span>
<span class="token punctuation">)</span>
</code></pre></div><p>此时，只有当 props.source 改变后才会重新创建订阅。</p> <p>注意：</p> <ul><li><p>如果你要使用此优化方式，请确保数组中包含了所有外部作用域中会发生变化且在 effect 中使用的变量，否则你的代码会引用到先前渲染中的旧变量。</p></li> <li><p>如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。</p></li></ul> <h4 id="usecontext"><a href="#usecontext" aria-hidden="true" class="header-anchor">#</a> useContext</h4> <p><code>const value = useContext(MyContext)</code></p> <p>接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。</p> <p>当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染。</p> <p>示例：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> themes <span class="token operator">=</span> <span class="token punctuation">{</span>
  foreground<span class="token punctuation">:</span><span class="token string">&quot;#000000&quot;</span><span class="token punctuation">,</span>
  background<span class="token punctuation">:</span><span class="token string">&quot;#eeeeee&quot;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> ThemeContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span>themes<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span><span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>ThemeContext<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token punctuation">{</span>themes<span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Toolbar<span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>ThemeContext<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Toolbar</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span><span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ThemedButton<span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">ThemedButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>ThemeContext<span class="token punctuation">)</span>
  <span class="token keyword">return</span><span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>button style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>background<span class="token punctuation">:</span>theme<span class="token punctuation">.</span>background<span class="token punctuation">,</span>color<span class="token punctuation">:</span>theme<span class="token punctuation">.</span>foreground<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
    <span class="token constant">I</span> am styled by theme context<span class="token operator">!</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="usereducer"><a href="#usereducer" aria-hidden="true" class="header-anchor">#</a> useReducer</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span>dispacth<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span>initialArg<span class="token punctuation">,</span>init<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法</p> <p>在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> initialState <span class="token operator">=</span> <span class="token punctuation">{</span>count<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">reducer</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'increment'</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>count<span class="token punctuation">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">'decrement'</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>count<span class="token punctuation">:</span> state<span class="token punctuation">.</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token punctuation">:</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> initialState<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
      Count<span class="token punctuation">:</span> <span class="token punctuation">{</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>type<span class="token punctuation">:</span> <span class="token string">'decrement'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">-</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>type<span class="token punctuation">:</span> <span class="token string">'increment'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">+</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>初始化state</strong></p> <p>有两种不同初始化 useReducer state 的方式，你可以根据使用场景选择其中的一种。将初始 state 作为第二个参数传入 useReducer 是最简单的方法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>
    reducer<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>count<span class="token punctuation">:</span> initialCount<span class="token punctuation">}</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>也可以选择惰性地创建初始 state。为此，需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)。</p> <h4 id="usecallback-2"><a href="#usecallback-2" aria-hidden="true" class="header-anchor">#</a> useCallback</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> memoizedCallback <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">doSomething</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>返回一个 memoized 回调函数。</p> <p>把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新</p> <p>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)</p> <h4 id="usememo-2"><a href="#usememo-2" aria-hidden="true" class="header-anchor">#</a> useMemo</h4> <p><code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b])</code></p> <p>返回一个 memoized 值。</p> <p>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算</p> <p>记住，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。</p> <p>如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值</p> <h4 id="useref"><a href="#useref" aria-hidden="true" class="header-anchor">#</a> useRef</h4> <p><code>const refContainer = useRef(initialValue)</code></p> <p>useRef 返回一个可变的ref对象，其.current属性被初始化为传入的参数(initialValue).返回的ref对象在组件的整个生命周期内保持不变</p> <p>示例：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">TextInputWithFocusButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> inputEl <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">onButtonClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span>
    inputEl<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span>inputEl<span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onButtonClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>Focus the input<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="事件机制"><a href="#事件机制" aria-hidden="true" class="header-anchor">#</a> 事件机制</h2> <p>本文是基于V16.13.1进行的分析。</p> <h3 id="事件注册与存储"><a href="#事件注册与存储" aria-hidden="true" class="header-anchor">#</a> 事件注册与存储</h3> <p>注册与存储的大体函数调用顺序如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ReactFiberCompleteWork.old.js</span>

finalizeInitialChildren  <span class="token comment">//  ReactDOMHostConfig.js</span>

setInitialProperties <span class="token comment">// ReactDOMComponent.js</span>

setInitialDOMProperties <span class="token comment">// ReactDOMComponent.js</span>

ensureListeningTo <span class="token comment">// ReactDOMComponent.js</span>

listenToReactEvent <span class="token comment">// DOMPluginEventSystem.js</span>

getEventListenerMap <span class="token comment">// ReactDOMComponentTree.js</span>

listenToNativeEvent <span class="token comment">// DOMPluginEventSystem.js</span>

addTrappedEventListener <span class="token comment">//  DOMPluginEventSystem.js</span>

createEventListenerWrapperWithPriority <span class="token comment">// ReactDOMEventListener.js 注入了dispatchEvent</span>

addEventCaptureListenerWithPassiveFlag、addEventCaptureListener、addEventBubbleListenerWithPassiveFlag 、addEventBubbleListener <span class="token comment">// EventListener.js</span>

target<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> listener<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// EventListener.js</span>

</code></pre></div><p><strong>setInitialDOMProperties</strong> 方法</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">setInitialDOMProperties</span><span class="token punctuation">(</span>
  <span class="token parameter">tag<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  domElement<span class="token punctuation">:</span> Element<span class="token punctuation">,</span>
  rootContainerElement<span class="token punctuation">:</span> Element <span class="token operator">|</span> Document<span class="token punctuation">,</span>
  nextProps<span class="token punctuation">:</span> Object<span class="token punctuation">,</span>
  isCustomComponentTag<span class="token punctuation">:</span> boolean<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> propKey <span class="token keyword">in</span> nextProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nextProps<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>propKey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> nextProp <span class="token operator">=</span> nextProps<span class="token punctuation">[</span>propKey<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>propKey <span class="token operator">===</span> <span class="token constant">STYLE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// ...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>registrationNameDependencies<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>propKey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>nextProp <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>enableEagerRootListeners<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">ensureListeningTo</span><span class="token punctuation">(</span>rootContainerElement<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> domElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当propKey在<code>registrationNameDependencies</code>列表中时，会调用<code>ensureListeningTo</code>方法。这里的<code>registrationNameDependencies</code>存储了React事件类型与浏览器原生事件类型映射的一个map对象。
<img src="/assets/img/registrationNameDependencies.0648db1b.png" alt=""></p> <p>其中<code>onChange</code>的dependences</p> <p><img src="/assets/img/registrationNameDependencies.0648db1b.png" alt=""></p> <p><strong>listenToReactEvent</strong> 方法</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">listenToReactEvent</span><span class="token punctuation">(</span>
  reactEvent<span class="token punctuation">:</span> string<span class="token punctuation">,</span> <span class="token comment">// 例如onChange</span>
  rootContainerElement<span class="token punctuation">:</span> Element<span class="token punctuation">,</span>
  targetElement<span class="token punctuation">:</span> Element <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token comment">// dependences这边可以理解为事件依赖，就是说注册某个事件，react会强制依赖其他事件。 如上图的onChange</span>
  <span class="token keyword">const</span> dependencies <span class="token operator">=</span> registrationNameDependencies<span class="token punctuation">[</span>reactEvent<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> dependenciesLength <span class="token operator">=</span> dependencies<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">const</span> isPolyfillEventPlugin <span class="token operator">=</span> dependenciesLength <span class="token operator">!==</span> <span class="token number">1</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>isPolyfillEventPlugin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 首次返回一个空的map对象</span>
    <span class="token keyword">const</span> listenerMap <span class="token operator">=</span> <span class="token function">getEventListenerMap</span><span class="token punctuation">(</span>rootContainerElement<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// listenerMap不包含当前事件属性，就进入判断(has是判断属性是否存在，即使内容为null，也是返回true)</span>
    <span class="token comment">// 也就是同一种事件只会注册一遍，onChange、onClick等等</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>listenerMap<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>reactEvent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 给对象添加一个reactEvent属性，值为null</span>
      listenerMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>reactEvent<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这个listenerMap会变成{onChange: null}</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dependenciesLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 循环遍历dependencies</span>
        <span class="token function">listenToNativeEvent</span><span class="token punctuation">(</span>
          dependencies<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// dependence</span>
          <span class="token boolean">false</span><span class="token punctuation">,</span>
          rootContainerElement<span class="token punctuation">,</span>
          targetElement<span class="token punctuation">,</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> isCapturePhaseListener <span class="token operator">=</span>
      reactEvent<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'Capture'</span> <span class="token operator">&amp;&amp;</span>
      reactEvent<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token string">'Pointer'</span><span class="token punctuation">;</span>
    <span class="token function">listenToNativeEvent</span><span class="token punctuation">(</span>
      dependencies<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      isCapturePhaseListener<span class="token punctuation">,</span>
      rootContainerElement<span class="token punctuation">,</span>
      targetElement<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>getEventListenerMap</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> randomKey <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> internalEventHandlersKey <span class="token operator">=</span> <span class="token string">'__reactEvents$'</span> <span class="token operator">+</span> randomKey<span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getEventListenerMap</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">:</span> EventTarget</span><span class="token punctuation">)</span><span class="token punctuation">:</span> ElementListenerMap <span class="token punctuation">{</span>
  <span class="token keyword">let</span> elementListenerMap <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">[</span>internalEventHandlersKey<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>elementListenerMap <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    elementListenerMap <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">[</span>internalEventHandlersKey<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> elementListenerMap<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>🔥 <strong>listenToNativeEvent</strong> 存储</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">listenToNativeEvent</span><span class="token punctuation">(</span>
  <span class="token parameter">domEventName<span class="token punctuation">:</span> DOMEventName<span class="token punctuation">,</span>
  isCapturePhaseListener<span class="token punctuation">:</span> boolean<span class="token punctuation">,</span>
  rootContainerElement<span class="token punctuation">:</span> EventTarget<span class="token punctuation">,</span>
  targetElement<span class="token punctuation">:</span> Element <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  isPassiveListener<span class="token operator">?</span><span class="token punctuation">:</span> boolean<span class="token punctuation">,</span>
  listenerPriority<span class="token operator">?</span><span class="token punctuation">:</span> EventPriority<span class="token punctuation">,</span>
  eventSystemFlags<span class="token operator">?</span><span class="token punctuation">:</span> EventSystemFlags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> target <span class="token operator">=</span> rootContainerElement<span class="token punctuation">;</span> <span class="token comment">// div#root</span>
  <span class="token comment">// ...</span>

  <span class="token comment">// 这边去获取上面提到的那个map对象</span>
  <span class="token keyword">const</span> listenerMap <span class="token operator">=</span> <span class="token function">getEventListenerMap</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// export function getListenerMapKey(</span>
  <span class="token comment">//   domEventName: DOMEventName,</span>
  <span class="token comment">//   capture: boolean,</span>
  <span class="token comment">// ): string {</span>
  <span class="token comment">//   return `${domEventName}__${capture ? 'capture' : 'bubble'}`; </span>
  <span class="token comment">// }</span>

  <span class="token comment">// 获取到的listenerMapKey值是 onChange_bubble</span>
  <span class="token keyword">const</span> listenerMapKey <span class="token operator">=</span> <span class="token function">getListenerMapKey</span><span class="token punctuation">(</span>
    domEventName<span class="token punctuation">,</span>
    isCapturePhaseListener<span class="token punctuation">,</span> <span class="token comment">// false</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">// 判断listenerMap中是否存在listenerMapKey</span>
  <span class="token keyword">const</span> listenerEntry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>listenerMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>
    listenerMapKey<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">:</span> ElementListenerMapEntry <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 判断是否需要更新</span>
  <span class="token keyword">const</span> shouldUpgrade <span class="token operator">=</span> <span class="token function">shouldUpgradeListener</span><span class="token punctuation">(</span>listenerEntry<span class="token punctuation">,</span> isPassiveListener<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token comment">// 如果不存在当前事件，或者需要更新，进入判断</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>listenerEntry <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">||</span> shouldUpgrade<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldUpgrade<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">removeEventListener</span><span class="token punctuation">(</span>
        target<span class="token punctuation">,</span>
        domEventName<span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span>listenerEntry<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">:</span> ElementListenerMapEntry<span class="token punctuation">)</span><span class="token punctuation">.</span>listener<span class="token punctuation">,</span>
        isCapturePhaseListener<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isCapturePhaseListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      eventSystemFlags <span class="token operator">|=</span> <span class="token constant">IS_CAPTURE_PHASE</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// addTrappedEventListener内部就是做了：在target上进行事件监听，并返回dispatchEvent函数</span>
    <span class="token keyword">const</span> listener <span class="token operator">=</span> <span class="token function">addTrappedEventListener</span><span class="token punctuation">(</span>
      target<span class="token punctuation">,</span> <span class="token comment">// div#root</span>
      domEventName<span class="token punctuation">,</span> <span class="token comment">// onChange</span>
      eventSystemFlags<span class="token punctuation">,</span> <span class="token comment">// 0</span>
      isCapturePhaseListener<span class="token punctuation">,</span> <span class="token comment">//false</span>
      <span class="token boolean">false</span><span class="token punctuation">,</span>
      isPassiveListener<span class="token punctuation">,</span>
      listenerPriority<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 最终这个listenerMap会变成{onChange: null, change_bubble: {passive: isPassiveListener, listener}}</span>
    listenerMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>listenerMapKey<span class="token punctuation">,</span> <span class="token punctuation">{</span>passive<span class="token punctuation">:</span> isPassiveListener<span class="token punctuation">,</span> listener<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>listenerMap的结构
<img src="/assets/img/listenerMap.d3d8c17d.png" alt=""></p> <p>🔥 <strong>addTrappedEventListener</strong> 事件注册</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">addTrappedEventListener</span><span class="token punctuation">(</span>
  targetContainer<span class="token punctuation">:</span> EventTarget<span class="token punctuation">,</span> <span class="token comment">// div#root</span>
  domEventName<span class="token punctuation">:</span> DOMEventName<span class="token punctuation">,</span> <span class="token comment">// onChange</span>
  eventSystemFlags<span class="token punctuation">:</span> EventSystemFlags<span class="token punctuation">,</span> <span class="token comment">// 0</span>
  isCapturePhaseListener<span class="token punctuation">:</span> boolean<span class="token punctuation">,</span> <span class="token comment">// false</span>
  isDeferredListenerForLegacyFBSupport<span class="token operator">?</span><span class="token punctuation">:</span> boolean<span class="token punctuation">,</span>
  isPassiveListener<span class="token operator">?</span><span class="token punctuation">:</span> boolean<span class="token punctuation">,</span>
  listenerPriority<span class="token operator">?</span><span class="token punctuation">:</span> EventPriority<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token parameter">any</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>

  <span class="token comment">// 这段代码尤为重要，通过传入的domEventName获取当前事件的优先级，返回的是经过包装过的三类dispatchEvent事件</span>
  <span class="token comment">// 分别为dispatchDiscreteEvent =&gt;0 | dispatchUserBlockingUpdate =&gt;1 | dispatchEvent=&gt;2</span>

  <span class="token comment">// export function createEventListenerWrapperWithPriority(</span>
  <span class="token comment">//   targetContainer: EventTarget,</span>
  <span class="token comment">//   domEventName: DOMEventName,</span>
  <span class="token comment">//   eventSystemFlags: EventSystemFlags,</span>
  <span class="token comment">//   priority?: EventPriority,</span>
  <span class="token comment">// ): Function {</span>
  <span class="token comment">//   const eventPriority =</span>
  <span class="token comment">//     priority === undefined</span>
  <span class="token comment">//       ? getEventPriorityForPluginSystem(domEventName)</span>
  <span class="token comment">//       : priority;</span>
  <span class="token comment">//   let listenerWrapper;</span>
  <span class="token comment">//   switch (eventPriority) {</span>
  <span class="token comment">//     case DiscreteEvent:</span>
  <span class="token comment">//       listenerWrapper = dispatchDiscreteEvent;</span>
  <span class="token comment">//       break;</span>
  <span class="token comment">//     case UserBlockingEvent:</span>
  <span class="token comment">//       listenerWrapper = dispatchUserBlockingUpdate;</span>
  <span class="token comment">//       break;</span>
  <span class="token comment">//     case ContinuousEvent:</span>
  <span class="token comment">//     default:</span>
  <span class="token comment">//       listenerWrapper = dispatchEvent;</span>
  <span class="token comment">//       break;</span>
  <span class="token comment">//   }</span>
  <span class="token comment">//   return listenerWrapper.bind(</span>
  <span class="token comment">//     null,</span>
  <span class="token comment">//     domEventName,</span>
  <span class="token comment">//     eventSystemFlags,</span>
  <span class="token comment">//     targetContainer,</span>
  <span class="token comment">//   );</span>
  <span class="token comment">// }</span>

  <span class="token keyword">let</span> listener <span class="token operator">=</span> <span class="token function">createEventListenerWrapperWithPriority</span><span class="token punctuation">(</span>
    targetContainer<span class="token punctuation">,</span>
    domEventName<span class="token punctuation">,</span>
    eventSystemFlags<span class="token punctuation">,</span>
    listenerPriority<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// ...</span>


  <span class="token keyword">if</span> <span class="token punctuation">(</span>isCapturePhaseListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isPassiveListener <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      unsubscribeListener <span class="token operator">=</span> <span class="token function">addEventCaptureListenerWithPassiveFlag</span><span class="token punctuation">(</span>
        targetContainer<span class="token punctuation">,</span>
        domEventName<span class="token punctuation">,</span>
        listener<span class="token punctuation">,</span>
        isPassiveListener<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      unsubscribeListener <span class="token operator">=</span> <span class="token function">addEventCaptureListener</span><span class="token punctuation">(</span>
        targetContainer<span class="token punctuation">,</span>
        domEventName<span class="token punctuation">,</span>
        listener<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isPassiveListener <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      unsubscribeListener <span class="token operator">=</span> <span class="token function">addEventBubbleListenerWithPassiveFlag</span><span class="token punctuation">(</span>
        targetContainer<span class="token punctuation">,</span>
        domEventName<span class="token punctuation">,</span>
        listener<span class="token punctuation">,</span>
        isPassiveListener<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      unsubscribeListener <span class="token operator">=</span> <span class="token function">addEventBubbleListener</span><span class="token punctuation">(</span>
        targetContainer<span class="token punctuation">,</span>
        domEventName<span class="token punctuation">,</span>
        listener<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> unsubscribeListener<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>addEventCaptureListenerWithPassiveFlag、addEventCaptureListener、addEventBubbleListenerWithPassiveFlag 、addEventBubbleListener</code> 这四个方法本质都是调用的是<code>target.addEventListener(eventType, listener, true);</code>稍微有点差别</p> <p>到此 注册和存储已经完成啦</p> <p>总结：事件注册的流程就是遍历props中的event，然后将事件和其依赖事件都挂载到target上，当中所有的事件的回调函数走的都是dispatchEvent，并且相同类型的事件只会挂在一次。还有如果我绑定一个onChange事件，那么react不仅仅只绑定一个onChange事件到target上，还会绑定许多依赖事件上去，如focus,blur,input等等，组件中声明的事件并不会保存起来，而仅仅是将事件类型以及dispatchEvent函数绑定到target元素上，实现事件委派。</p> <h3 id="事件分发与执行"><a href="#事件分发与执行" aria-hidden="true" class="header-anchor">#</a> 事件分发与执行</h3> <p>函数调用顺序如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
dispatchEvent <span class="token comment">// ReactDOMEventListener.js</span>

dispatchEventForPluginEventSystem <span class="token comment">// DOMPluginEventSystem.js</span>

batchedEventUpdates <span class="token comment">// ReactDOMUpdateBatching.js</span>

dispatchEventsForPlugins <span class="token comment">// DOMPluginEventSystem.js // 该函数先合成事件 然后再执行</span>

extractEvents <span class="token comment">// DOMPluginEventSystem.js</span>

<span class="token comment">// 以ChangeEventPlugin为例子</span>

createAndAccumulateChangeEvent <span class="token comment">//  // react-dom/src/client/events/ChangeEventPlugin.js</span>

accumulateTwoPhaseListeners  <span class="token comment">// DOMPluginEventSystem.js</span>

processDispatchQueue <span class="token comment">// 在dispatchEventsForPlugins函数中调用</span>

executeDispatch  <span class="token comment">// DOMPluginEventSystem.js</span>

invokeGuardedCallbackAndCatchFirstError <span class="token comment">// shared/ReactErrorUtils</span>

</code></pre></div><p><strong>dispatchEvent</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">dispatchEvent</span><span class="token punctuation">(</span>
  domEventName<span class="token punctuation">:</span> DOMEventName<span class="token punctuation">,</span>  <span class="token comment">//onChange</span>
  eventSystemFlags<span class="token punctuation">:</span> EventSystemFlags<span class="token punctuation">,</span> <span class="token comment">// 0</span>
  targetContainer<span class="token punctuation">:</span> EventTarget<span class="token punctuation">,</span> <span class="token comment">//div#root</span>
  nativeEvent<span class="token punctuation">:</span> AnyNativeEvent<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>


  <span class="token comment">// ....</span>
  <span class="token function">dispatchEventForPluginEventSystem</span><span class="token punctuation">(</span>
    domEventName<span class="token punctuation">,</span>
    eventSystemFlags<span class="token punctuation">,</span>
    nativeEvent<span class="token punctuation">,</span>
    <span class="token keyword">null</span><span class="token punctuation">,</span>
    targetContainer<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>dispatchEventForPluginEventSystem</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">dispatchEventForPluginEventSystem</span><span class="token punctuation">(</span>
  <span class="token parameter">domEventName<span class="token punctuation">:</span> DOMEventName<span class="token punctuation">,</span>
  eventSystemFlags<span class="token punctuation">:</span> EventSystemFlags<span class="token punctuation">,</span>
  nativeEvent<span class="token punctuation">:</span> AnyNativeEvent<span class="token punctuation">,</span>
  targetInst<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> Fiber<span class="token punctuation">,</span>
  targetContainer<span class="token punctuation">:</span> EventTarget<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  <span class="token comment">//批量更新</span>
  <span class="token function">batchedEventUpdates</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    <span class="token function">dispatchEventsForPlugins</span><span class="token punctuation">(</span>
      domEventName<span class="token punctuation">,</span>
      eventSystemFlags<span class="token punctuation">,</span>
      nativeEvent<span class="token punctuation">,</span>
      ancestorInst<span class="token punctuation">,</span>
      targetContainer<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>batchedEventUpdates</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">batchedEventUpdates</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isBatchingEventUpdates<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 初始是false</span>
    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  isBatchingEventUpdates <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">batchedEventUpdatesImpl</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    isBatchingEventUpdates <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token function">finishEventHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>dispatchEventsForPlugins</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">dispatchEventsForPlugins</span><span class="token punctuation">(</span>
  <span class="token parameter">domEventName<span class="token punctuation">:</span> DOMEventName<span class="token punctuation">,</span>
  eventSystemFlags<span class="token punctuation">:</span> EventSystemFlags<span class="token punctuation">,</span>
  nativeEvent<span class="token punctuation">:</span> AnyNativeEvent<span class="token punctuation">,</span>
  targetInst<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> Fiber<span class="token punctuation">,</span>
  targetContainer<span class="token punctuation">:</span> EventTarget<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> nativeEventTarget <span class="token operator">=</span> <span class="token function">getEventTarget</span><span class="token punctuation">(</span>nativeEvent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前dom元素</span>
  <span class="token keyword">const</span> dispatchQueue<span class="token punctuation">:</span> DispatchQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 进行事件合成</span>
  <span class="token function">extractEvents</span><span class="token punctuation">(</span>
    dispatchQueue<span class="token punctuation">,</span>  <span class="token comment">// []</span>
    domEventName<span class="token punctuation">,</span> <span class="token comment">// onChange</span>
    targetInst<span class="token punctuation">,</span>
    nativeEvent<span class="token punctuation">,</span> <span class="token comment">// 原生事件</span>
    nativeEventTarget<span class="token punctuation">,</span> <span class="token comment">// 获取当前dom元素</span>
    eventSystemFlags<span class="token punctuation">,</span> <span class="token comment">// 0</span>
    targetContainer<span class="token punctuation">,</span> <span class="token comment">// div#root</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 按顺序执行事件队列,此时dispatchQueue已经变成[onChange, [{instance, listener, currentTarget}, ...]]</span>
  <span class="token function">processDispatchQueue</span><span class="token punctuation">(</span>dispatchQueue<span class="token punctuation">,</span> eventSystemFlags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>🔥 <strong>extractEvents事件合成</strong></p> <p>extractEvents这个方法就是调用各种插件来创建相应函数的合成事件，一共有6种插件，这边用到了5个。事件的合成，冒泡的处理以及事件回调的查找都是在合成阶段完成的。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">extractEvents</span><span class="token punctuation">(</span>
  dispatchQueue<span class="token punctuation">:</span> DispatchQueue<span class="token punctuation">,</span> <span class="token comment">// 初始为[]</span>
  domEventName<span class="token punctuation">:</span> DOMEventName<span class="token punctuation">,</span> <span class="token comment">// dependence</span>
  targetInst<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> Fiber<span class="token punctuation">,</span> <span class="token comment">// </span>
  nativeEvent<span class="token punctuation">:</span> AnyNativeEvent<span class="token punctuation">,</span> <span class="token comment">// 原生事件</span>
  nativeEventTarget<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> EventTarget<span class="token punctuation">,</span> <span class="token comment">// 当前dom元素</span>
  eventSystemFlags<span class="token punctuation">:</span> EventSystemFlags<span class="token punctuation">,</span>
  targetContainer<span class="token punctuation">:</span> EventTarget<span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  SimpleEventPlugin<span class="token punctuation">.</span><span class="token function">extractEvents</span><span class="token punctuation">(</span>
    dispatchQueue<span class="token punctuation">,</span>
    domEventName<span class="token punctuation">,</span>
    targetInst<span class="token punctuation">,</span>
    nativeEvent<span class="token punctuation">,</span>
    nativeEventTarget<span class="token punctuation">,</span>
    eventSystemFlags<span class="token punctuation">,</span>
    targetContainer<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> shouldProcessPolyfillPlugins <span class="token operator">=</span> <span class="token punctuation">(</span>eventSystemFlags <span class="token operator">&amp;</span> <span class="token constant">SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldProcessPolyfillPlugins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    EnterLeaveEventPlugin<span class="token punctuation">.</span><span class="token function">extractEvents</span><span class="token punctuation">(</span>
      <span class="token operator">...</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    ChangeEventPlugin<span class="token punctuation">.</span><span class="token function">extractEvents</span><span class="token punctuation">(</span>
      <span class="token operator">...</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    SelectEventPlugin<span class="token punctuation">.</span><span class="token function">extractEvents</span><span class="token punctuation">(</span>
      <span class="token operator">...</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    BeforeInputEventPlugin<span class="token punctuation">.</span><span class="token function">extractEvents</span><span class="token punctuation">(</span>
     <span class="token operator">...</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们以ChangeEventPlugin插件举例：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// react-dom/src/client/events/ChangeEventPlugin.js</span>

<span class="token keyword">function</span> <span class="token function">extractEvents</span><span class="token punctuation">(</span>
  <span class="token parameter">dispatchQueue<span class="token punctuation">:</span> DispatchQueue<span class="token punctuation">,</span>
  domEventName<span class="token punctuation">:</span> DOMEventName<span class="token punctuation">,</span>
  targetInst<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> Fiber<span class="token punctuation">,</span>
  nativeEvent<span class="token punctuation">:</span> AnyNativeEvent<span class="token punctuation">,</span>
  nativeEventTarget<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> EventTarget<span class="token punctuation">,</span>
  eventSystemFlags<span class="token punctuation">:</span> EventSystemFlags<span class="token punctuation">,</span>
  targetContainer<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> EventTarget<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> targetNode <span class="token operator">=</span> targetInst <span class="token operator">?</span> <span class="token function">getNodeFromInstance</span><span class="token punctuation">(</span>targetInst<span class="token punctuation">)</span> <span class="token punctuation">:</span> window<span class="token punctuation">;</span>

  <span class="token keyword">let</span> getTargetInstFunc<span class="token punctuation">,</span> handleEventFunc<span class="token punctuation">;</span>
  <span class="token comment">// 这边判断当前的节点符不符合当前插件创建相应合成事件的要求</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldUseChangeEvent</span><span class="token punctuation">(</span>targetNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    getTargetInstFunc <span class="token operator">=</span> getTargetInstForChangeEvent<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isTextInputElement</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>targetNode<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">:</span> HTMLElement<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isInputEventSupported<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      getTargetInstFunc <span class="token operator">=</span> getTargetInstForInputOrChangeEvent<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      getTargetInstFunc <span class="token operator">=</span> getTargetInstForInputEventPolyfill<span class="token punctuation">;</span>
      handleEventFunc <span class="token operator">=</span> handleEventsForInputEventPolyfill<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldUseClickEvent</span><span class="token punctuation">(</span>targetNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    getTargetInstFunc <span class="token operator">=</span> getTargetInstForClickEvent<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>getTargetInstFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> inst <span class="token operator">=</span> <span class="token function">getTargetInstFunc</span><span class="token punctuation">(</span>domEventName<span class="token punctuation">,</span> targetInst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inst<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">createAndAccumulateChangeEvent</span><span class="token punctuation">(</span>
        dispatchQueue<span class="token punctuation">,</span>
        inst<span class="token punctuation">,</span>
        nativeEvent<span class="token punctuation">,</span>
        nativeEventTarget<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>handleEventFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">handleEventFunc</span><span class="token punctuation">(</span>domEventName<span class="token punctuation">,</span> targetNode<span class="token punctuation">,</span> targetInst<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>domEventName <span class="token operator">===</span> <span class="token string">'focusout'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">handleControlledInputBlur</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>targetNode<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">:</span> HTMLInputElement<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>createAndAccumulateChangeEvent</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createAndAccumulateChangeEvent</span><span class="token punctuation">(</span>
  <span class="token parameter">dispatchQueue<span class="token punctuation">,</span>
  inst<span class="token punctuation">,</span>
  nativeEvent<span class="token punctuation">,</span>
  target<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 生成合成事件</span>
  <span class="token keyword">const</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SyntheticEvent</span><span class="token punctuation">(</span>
    <span class="token string">'onChange'</span><span class="token punctuation">,</span>
    <span class="token string">'change'</span><span class="token punctuation">,</span>
    <span class="token keyword">null</span><span class="token punctuation">,</span>
    nativeEvent<span class="token punctuation">,</span>
    target<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Flag this event loop as needing state restore.</span>
  <span class="token function">enqueueStateRestore</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>target<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">:</span> Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">accumulateTwoPhaseListeners</span><span class="token punctuation">(</span>inst<span class="token punctuation">,</span> dispatchQueue<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>🔥 <strong>accumulateTwoPhaseListeners 事件分发</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">accumulateTwoPhaseListeners</span><span class="token punctuation">(</span>
  targetFiber<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> 
  dispatchQueue<span class="token punctuation">:</span> DispatchQueue<span class="token punctuation">,</span> <span class="token comment">// []</span>
  event<span class="token punctuation">:</span> ReactSyntheticEvent<span class="token punctuation">,</span> <span class="token comment">// onChange合成事件</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> bubbled <span class="token operator">=</span> event<span class="token punctuation">.</span>_reactName<span class="token punctuation">;</span> <span class="token comment">// 就是“onChange”</span>
  <span class="token keyword">const</span> captured <span class="token operator">=</span> bubbled <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">?</span> bubbled <span class="token operator">+</span> <span class="token string">'Capture'</span> <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 就是“onChangeCapture”</span>
  <span class="token keyword">const</span> listeners<span class="token punctuation">:</span> Array<span class="token operator">&lt;</span>DispatchListener<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> instance <span class="token operator">=</span> targetFiber<span class="token punctuation">;</span>

  <span class="token comment">// 这边向上查找到所有当前类型事件的回调函数，重要！！！</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>instance <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span>stateNode<span class="token punctuation">,</span> tag<span class="token punctuation">}</span> <span class="token operator">=</span> instance<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tag <span class="token operator">===</span> HostComponent <span class="token operator">&amp;&amp;</span> stateNode <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> currentTarget <span class="token operator">=</span> stateNode<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>captured <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 返回当前节点的回调函数</span>

      <span class="token comment">// export default function getListener(</span>
      <span class="token comment">//   inst: Fiber, // 当前实例</span>
      <span class="token comment">//   registrationName: string, // “onChange”</span>
      <span class="token comment">// ): Function | null {</span>
      <span class="token comment">//   ...</span>
      <span class="token comment">//   // 返回dom上的props</span>
      <span class="token comment">//   const props = getFiberCurrentPropsFromNode(stateNode);</span>
      <span class="token comment">//   if (props === null) {</span>
      <span class="token comment">//     // Work in progress.</span>
      <span class="token comment">//     return null;</span>
      <span class="token comment">//   }</span>
      <span class="token comment">//   // 获取到当前事件的回调函数</span>
      <span class="token comment">//   const listener = props[registrationName]</span>
      <span class="token comment">//   return listener;</span>
      <span class="token comment">// }</span>

        <span class="token keyword">const</span> captureListener <span class="token operator">=</span> <span class="token function">getListener</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> captured<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>captureListener <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 捕获，插入数组头部</span>
          listeners<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>
            <span class="token comment">// 工具函数，返回对象{instance, listener, currentTarget}</span>
            <span class="token function">createDispatchListener</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> captureListener<span class="token punctuation">,</span> currentTarget<span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>bubbled <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 返回当前节点的回调函数</span>
        <span class="token keyword">const</span> bubbleListener <span class="token operator">=</span> <span class="token function">getListener</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> bubbled<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>bubbleListener <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 冒泡，插入数组尾部</span>
          listeners<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>
            <span class="token comment">// 工具函数，返回对象{instance, listener, currentTarget}</span>
            <span class="token function">createDispatchListener</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> bubbleListener<span class="token punctuation">,</span> currentTarget<span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    instance <span class="token operator">=</span> instance<span class="token punctuation">.</span>return<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// listeners即某一类合成事件的所有回调函数的集合，[{instance, listener, currentTarget}, ...]</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>listeners<span class="token punctuation">.</span>length <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// createDispatchEntry返回的是对象{event, listeners};</span>
    <span class="token comment">// dispatchQueue最后为[{event, listeners}, ...], 即[{onChange, [{instance, listener, currentTarget}, ...]}, ...]</span>
    dispatchQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">createDispatchEntry</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> listeners<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>🔥 <strong>processDispatchQueue事件执行</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">processDispatchQueue</span><span class="token punctuation">(</span>
  <span class="token parameter">dispatchQueue<span class="token punctuation">:</span> DispatchQueue<span class="token punctuation">,</span>
  eventSystemFlags<span class="token punctuation">:</span> EventSystemFlags<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> inCapturePhase <span class="token operator">=</span> <span class="token punctuation">(</span>eventSystemFlags <span class="token operator">&amp;</span> <span class="token constant">IS_CAPTURE_PHASE</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">// 循环取出合成事件和对应的回调函数队列</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dispatchQueue<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span>event<span class="token punctuation">,</span> listeners<span class="token punctuation">}</span> <span class="token operator">=</span> dispatchQueue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// 逐个执行每个回调函数</span>
    <span class="token function">processDispatchQueueItemsInOrder</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> inCapturePhase<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//  event system doesn't use pooling. 不在使用事件池</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// This would be a good time to rethrow if any of the event handlers threw.</span>
  <span class="token function">rethrowCaughtError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>processDispatchQueueItemsInOrder</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">processDispatchQueueItemsInOrder</span><span class="token punctuation">(</span>
  <span class="token parameter">event<span class="token punctuation">:</span> ReactSyntheticEvent<span class="token punctuation">,</span>
  dispatchListeners<span class="token punctuation">:</span> Array<span class="token operator">&lt;</span>DispatchListener<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  inCapturePhase<span class="token punctuation">:</span> boolean<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> previousInstance<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>inCapturePhase<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> dispatchListeners<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span>instance<span class="token punctuation">,</span> currentTarget<span class="token punctuation">,</span> listener<span class="token punctuation">}</span> <span class="token operator">=</span> dispatchListeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">!==</span> previousInstance <span class="token operator">&amp;&amp;</span> event<span class="token punctuation">.</span><span class="token function">isPropagationStopped</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token function">executeDispatch</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> listener<span class="token punctuation">,</span> currentTarget<span class="token punctuation">)</span><span class="token punctuation">;</span>
      previousInstance <span class="token operator">=</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dispatchListeners<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span>instance<span class="token punctuation">,</span> currentTarget<span class="token punctuation">,</span> listener<span class="token punctuation">}</span> <span class="token operator">=</span> dispatchListeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">!==</span> previousInstance <span class="token operator">&amp;&amp;</span> event<span class="token punctuation">.</span><span class="token function">isPropagationStopped</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token function">executeDispatch</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> listener<span class="token punctuation">,</span> currentTarget<span class="token punctuation">)</span><span class="token punctuation">;</span>
      previousInstance <span class="token operator">=</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>executeDispatch</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">executeDispatch</span><span class="token punctuation">(</span>
  event<span class="token punctuation">:</span> ReactSyntheticEvent<span class="token punctuation">,</span> <span class="token comment">// onChange</span>
  listener<span class="token punctuation">:</span> Function<span class="token punctuation">,</span> <span class="token comment">// 对应的回调函数</span>
  currentTarget<span class="token punctuation">:</span> EventTarget<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token comment">// &quot;onChange&quot;</span>
  <span class="token keyword">const</span> type <span class="token operator">=</span> event<span class="token punctuation">.</span>type <span class="token operator">||</span> <span class="token string">'unknown-event'</span><span class="token punctuation">;</span> 
  <span class="token comment">// 将当前dom元素赋值给合成事件的currentTarget</span>
  event<span class="token punctuation">.</span>currentTarget <span class="token operator">=</span> currentTarget<span class="token punctuation">;</span>
  <span class="token comment">// 执行回调函数，listener为回调函数, event为合成事件,最后执行listener(event)这个方法调用</span>
  <span class="token comment">// 这样就回调到了我们在JSX中注册的callback。比如onClick={(event) =&gt; {console.log(1)}}</span>
  <span class="token comment">// 现在就明白了callback怎么被调用的,以及event参数怎么传入callback里面的了</span>
  <span class="token function">invokeGuardedCallbackAndCatchFirstError</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> listener<span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>
  event<span class="token punctuation">.</span>currentTarget <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// invokeGuardedCallbackAndCatchFirstError 函数的本质是如下函数</span>
<span class="token comment">// shared/invokeGuardedCallbackImpl.js</span>

<span class="token keyword">function</span> invokeGuardedCallbackProd<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">,</span> <span class="token constant">D</span><span class="token punctuation">,</span> <span class="token constant">E</span><span class="token punctuation">,</span> <span class="token constant">F</span><span class="token punctuation">,</span> Context<span class="token operator">&gt;</span><span class="token punctuation">(</span>
  name<span class="token punctuation">:</span> string <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token function-variable function">func</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">:</span> <span class="token constant">A</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token constant">B</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token constant">C</span><span class="token punctuation">,</span> d<span class="token punctuation">:</span> <span class="token constant">D</span><span class="token punctuation">,</span> e<span class="token punctuation">:</span> <span class="token constant">E</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> <span class="token constant">F</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> mixed<span class="token punctuation">,</span>
  context<span class="token punctuation">:</span> Context<span class="token punctuation">,</span>
  a<span class="token punctuation">:</span> <span class="token constant">A</span><span class="token punctuation">,</span>
  b<span class="token punctuation">:</span> <span class="token constant">B</span><span class="token punctuation">,</span>
  c<span class="token punctuation">:</span> <span class="token constant">C</span><span class="token punctuation">,</span>
  d<span class="token punctuation">:</span> <span class="token constant">D</span><span class="token punctuation">,</span>
  e<span class="token punctuation">:</span> <span class="token constant">E</span><span class="token punctuation">,</span>
  f<span class="token punctuation">:</span> <span class="token constant">F</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> funcArgs <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">//最后就是在这里执行的回调函数</span>
    <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> funcArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="faq"><a href="#faq" aria-hidden="true" class="header-anchor">#</a> FAQ</h3> <h4 id="为什么需要手动绑定this"><a href="#为什么需要手动绑定this" aria-hidden="true" class="header-anchor">#</a> 为什么需要手动绑定this</h4> <p><code>invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event)</code></p> <p>该方法第三个参数是<code>undefined</code>对应底层<code>invokeGuardedCallbackProd</code>函数调用时的参数context</p> <p>那么 <code>func.apply(context, funcArgs)</code>函数的this 就是undefined 所以需要你定义回调函数的this指向，比如使用箭头函数</p> <h4 id="react事件和原生事件的执行顺序"><a href="#react事件和原生事件的执行顺序" aria-hidden="true" class="header-anchor">#</a> React事件和原生事件的执行顺序</h4> <p>当点击test时，如下代码的输出顺序是什么呢？</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'dom parent'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>child<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'dom child'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'document'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function-variable function">childClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'react child'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function-variable function">parentClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'react parent'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>parentClick<span class="token punctuation">}</span> ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token parameter">ref</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> ref<span class="token punctuation">}</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>childClick<span class="token punctuation">}</span> ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token parameter">ref</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> ref<span class="token punctuation">}</span><span class="token operator">&gt;</span>
          test
        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

</code></pre></div><p>输出结果如下:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>dom child
dom parent
react child
react parent
document
</code></pre></div><p>由上面的流程我们可以理解：</p> <ul><li>react的所有事件都挂载在document中</li> <li>当真实dom触发后冒泡到document后才会对react事件进行处理</li> <li>所以原生的事件会先执行</li> <li>然后执行react合成事件</li> <li>最后执行真正在document上挂载的事件</li></ul> <h3 id="react-v17中的事件"><a href="#react-v17中的事件" aria-hidden="true" class="header-anchor">#</a> React v17中的事件</h3> <h4 id="更改事件委托"><a href="#更改事件委托" aria-hidden="true" class="header-anchor">#</a> 更改事件委托</h4> <p>在 React 17 中，React 将不再向 document 附加事件处理器。而会将事件处理器附加到渲染 React 树的根 DOM 容器中</p> <p>在 React 16 或更早版本中，React 会对大多数事件执行 document.addEventListener()。React 17 将会在底层调用 rootNode.addEventListener()。</p> <p>例如，如果模块中使用 document.addEventListener(...) 手动添加了 DOM 监听，你可能希望能捕获到所有 React 事件。在 React 16 或更早版本中，即使你在 React 事件处理器中调用 e.stopPropagation()，你创建的 DOM 监听仍会触发，这是因为原生事件已经处于 document 级别。使用 React 17 冒泡将被阻止（按需），因此你的 document 级别的事件监听不会触发：</p> <h4 id="去除事件池"><a href="#去除事件池" aria-hidden="true" class="header-anchor">#</a> 去除事件池</h4> <p>React 17 中移除了 “event pooling（事件池）“。它并不会提高现代浏览器的性能，甚至还会使经验丰富的开发者一头雾水。</p> <h2 id="diffing-algorithm"><a href="#diffing-algorithm" aria-hidden="true" class="header-anchor">#</a> Diffing Algorithm</h2> <h3 id="三个基本策略"><a href="#三个基本策略" aria-hidden="true" class="header-anchor">#</a> 三个基本策略</h3> <ol><li>只对同级的 react element进行对比。如果一个DOM节点在前后两次更新中跨域了层级，那么则不会复用它。比较点为父节点的不同。</li> <li>不同类型节点(type 值不同 和key值)生成的dom树不同，此时会直接销毁老节点及子孙节点，并新建节点</li> <li>可以通过key来对元素diff的过程提供复用的线索</li></ol> <h3 id="同级节点diff"><a href="#同级节点diff" aria-hidden="true" class="header-anchor">#</a> 同级节点Diff</h3> <p>同级节点Diff 分为 同级单节点Diff 和 同级多节点Diff</p> <h4 id="同级节点diff-2"><a href="#同级节点diff-2" aria-hidden="true" class="header-anchor">#</a> 同级节点Diff</h4> <p>同级单节点diff有如下几种情况：</p> <ul><li>key 和 type 相同代表可以复用</li> <li>key 不同直接删除标记节点 新建节点</li> <li>key相同type不同，标记删除该节点和兄弟节点，然后新创建节点</li></ul> <h4 id="同级多节点diff"><a href="#同级多节点diff" aria-hidden="true" class="header-anchor">#</a> 同级多节点Diff</h4> <p>同级多节点时有如下几种情况</p> <ul><li><p>节点更新（类型、属性更新）</p></li> <li><p>节点新增或者删除</p></li> <li><p>节点移动</p></li></ul> <p>同级节点Diff需要两次遍历，React团队认为在日常开发中，组件更新的频率最高。所以第一次遍历会处理更新的节点，第二轮遍历：处理剩下的不属于<code>更新</code>的节点。</p> <p>第一轮遍历</p> <p>因为老的节点存在于current Fiber中，所以它是个链表结构，还记得Fiber双缓存结构嘛，节点通过child、return、sibling连接，而newChildren存在于jsx当中，所以遍历对比的时候，首先让newChildren[i]<code>与</code>oldFiber对比，然后让i++、nextOldFiber = oldFiber.sibling。</p> <ol><li>从第一个节点开始遍历（i = 0），判断新、旧节点的类型（type）是否相同和 key 是否相同，如果 type 和 key 都相同，则说明对应的 DOM 可复用；</li> <li>如果这个节点对应的 DOM 可复用，则 i++，去判断下一组新、旧节点的 type 和 key，看它们对应的 DOM 是否可复用，如果可以复用，则重复步骤 2；</li> <li>如果不可复用，分两种情况：</li></ol> <ul><li><code>key</code>不同导致不可复用，立即跳出整个遍历，<strong>第一轮遍历结束。</strong></li> <li><code>key</code>相同<code>type</code>不同导致不可复用，会将<code>oldFiber</code>标记为<code>DELETION</code>，并继续遍历</li></ul> <ol start="4"><li>如果<code>newChildren</code>遍历完（即<code>i === newChildren.length - 1</code>）或者<code>oldFiber</code>遍历完（即<code>oldFiber.sibling === null</code>），跳出遍历，<strong>第一轮遍历结束。</strong></li></ol> <p>当遍历结束后，会有两种结果：</p> <ol><li>步骤3跳出的遍历，此时 newChildren 没有遍历完，oldFiber 也没有遍历完</li> <li>步骤4跳出的遍历 可能是 newChildren 遍历完 或者 oldFiber 遍历完 或者他们同时遍历完</li></ol> <p>第二轮遍历</p> <p>对于第一轮遍历的结果，我们分别讨论</p> <ol><li><p>newChildren 和 oldFiber 同时遍历完，这是最理想的情况，只要一轮遍历进行组件更新，此时diff结束</p></li> <li><p>newChildren 没有遍历完、oldFiber遍历完</p> <p>已有的<code>DOM节点</code>都复用了，这时还有新加入的节点，意味着本次更新有新节点插入，我们只需要遍历剩下的<code>newChildren</code>为生成的<code>workInProgress fiber</code>依次标记 Placement 新增。</p></li> <li><p>newChildren 遍历完、oldFiber没有遍历完</p> <p>意味着本次更新比之前的节点数量少，有节点被删除了。所以需要遍历剩下的<code>oldFiber</code>，依次标记<code>Deletion 删除</code>。</p></li> <li><p>newChildren 与 oldFiber都没有遍历完  这意味着有节点在这次更新中改变了位置，这是<code>Diff算法</code>最精髓也是最难懂的部分</p> <p>为了快速找到key对应的oldFiber 我们将所有还未处理的 oldFiber 存入以key 为key ，oldFiber 为value 的Map中。这个 map 叫做 <code>existingChildren</code></p> <p>接下来遍历剩余的newChildredn 通过newChildren[i].key 就能在map中找到key相同的oldFiber</p> <p>如果能找到 key相同的oldFiber 接下来就是判断它们的 type 是否相同：</p> <ul><li>假如 key 相同、type 也相同，说明该节点对应的 DOM 可复用，只是位置发生了变化；</li> <li>假如 key 相同、type 不同，则该节点对应的 DOM 不可复用，需要销毁原来的节点，并重新插入一个新的节点；</li></ul> <p>如果找不到的话，代表是一个新增节点</p> <p>以上两种情况处理了新增和删除的  剩下节点移动的</p> <p>这里有一个基准点的概念 React 使用 <code>lastPlacedIndex</code> 这个变量来存放「参考点」<code>lastPlacedIndex</code> 这个变量表示当前最后一个可复用的节点，对应在「旧同级节点链表」中的索引。初始值为 0</p> <p>在遍历剩下的 newChildren时，每一个新节点会通过 <code>existingChildren</code> 找到对应的旧节点，然后就可以得到旧节点的索引 <code>oldIndex</code>（即在「旧同级节点链表」中的位置）。</p> <p>接下来会进行以下判断：</p> <ul><li>假如 <code>oldIndex</code> &gt;= <code>lastPlacedIndex</code>，代表该复用节点不需要移动位置，并将 lastPlacedIndex = oldIndex；</li> <li>假如 <code>oldIndex</code> &lt; <code>lastPlacedIndex</code>，代表该节点需要向右移动，并且该节点需要移动到上一个遍历到的新节点的后面；</li></ul></li></ol> <h2 id="redux"><a href="#redux" aria-hidden="true" class="header-anchor">#</a> Redux</h2> <h3 id="三大原则"><a href="#三大原则" aria-hidden="true" class="header-anchor">#</a> 三大原则</h3> <ol><li>单一数据源</li></ol> <p>一个应用永远只有唯一的数据源</p> <ol start="2"><li>状态是只读的</li></ol> <p>不能直接的修改应用的状态，但是可以利用store.dispatch达到修改状态的目的</p> <ol start="3"><li>状态修改均由纯函数完成</li></ol> <p>通过定义reducer来确定状态的修改，每一个reducer 都是纯函数。</p> <p>数据流如图：</p> <p><img src="/assets/img/redux.e51d77cc.png" alt=""></p> <h3 id="核心api"><a href="#核心api" aria-hidden="true" class="header-anchor">#</a> 核心API</h3> <p>Redux 的核心是一个 <code>store</code> ，这个 <code>store</code> 由Redux提供的 <code>createStore(reducers[,initialState])</code> 方法生成。</p> <p><code>createStore</code> 函数具有2个参数，第一个参数为必须传入的 <code>reducers</code> ，第二个参数为可以选的初始化状态 <code>initialState</code></p> <h4 id="reducer"><a href="#reducer" aria-hidden="true" class="header-anchor">#</a> reducer</h4> <p>在Redux里，负责响应action并修改数据的角色就是reducer。reducer本质上是一个函数，其函数签名为 <code>reducer(perviousState,action)=&gt;newState</code> 。可以看出reducer的职责是根据perviousState和action 计算出新的 newState</p> <p>当reducer第一次执行的时候，并没有任何的perviousState, 但是需要返回一个新的newState，但是就会需要一个初始值initialState</p> <h4 id="createstore"><a href="#createstore" aria-hidden="true" class="header-anchor">#</a> createStore</h4> <p>createStore是Redux中最核心的API。通过该方法可以生成一个store 对象。该store对象本身具有4个方法。</p> <ol><li>getState():获取store中当前的状态</li> <li>dispatch(action):分发一个action,并返回这个action，这是唯一能改变store中数据的方式</li> <li>subscribe(listener):注册一个监听者，它在store发生变化时被调用</li> <li>replaceReducer(nextReducer):更新当前store里的reducer，一般只会在开发模式中调用</li></ol> <p>react-redux 的核心组件只有两个，Provider 和 connect，Provider 存放 Redux 里 store 的数据到 context 里，通过 connect 从 context 拿数据，通过 props 传递给 connect 所包裹的组件。</p> <h2 id="recoil"><a href="#recoil" aria-hidden="true" class="header-anchor">#</a> Recoil</h2> <p>Recoil是React的状态管理库，由Facebook官方推出，更加的贴合react内部的调用机制。<a href="https://recoiljs.org/" target="_blank" rel="noopener noreferrer">官网文档链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="核心概念"><a href="#核心概念" aria-hidden="true" class="header-anchor">#</a> 核心概念</h3> <p>使用Recoil,可以创建一个数据流图，该图从atoms(共享状态)通过selectors(纯函数)一直流到React组件。</p> <p>Atom是组件可以预订的状态单位。</p> <p>selectors是可以同步或异步转换此状态。</p> <h4 id="atoms-原子"><a href="#atoms-原子" aria-hidden="true" class="header-anchor">#</a> Atoms(原子)</h4> <p>Atom是最小状态单位。它们是可更新和可订阅的，当Atom被更新时，每个订阅的组件都将用新值重新呈现。如果从多个组件中使用同一个 Atom ，所有这些组件都会共享它们的状态。</p> <p>使用atom函数来创建Atoms：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> fontSizeState <span class="token operator">=</span> <span class="token function">atom</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  key<span class="token punctuation">:</span> <span class="token string">'fontSizeSstate'</span><span class="token punctuation">,</span>
  <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token number">12</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>原子需要一个独一无二的key，全局唯一。你可以使用<code>Symobl</code>类型作为key值。</p> <h4 id="selectors"><a href="#selectors" aria-hidden="true" class="header-anchor">#</a> Selectors</h4> <p>Selector 是一个入参为 Atom 或者其他 Selector 的纯函数。当它的上游 Atom 或者 Selector 更新时，它会进行重新计算。Selector 可以像 Atom 一样被组件订阅，当它更新时，订阅它的组件将会重新渲染。</p> <p>使用 selector 方法创建 Selector 实例。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> fontSizeLabelState <span class="token operator">=</span> <span class="token function">selector</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  key<span class="token punctuation">:</span> <span class="token string">'fontSizeLabelState'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">get</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> fontSize <span class="token operator">=</span> <span class="token keyword">get</span><span class="token punctuation">(</span>fontSizeState<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> unit <span class="token operator">=</span> <span class="token string">'px'</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>fontSize<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>unit<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>get 属性是一个计算函数，它可以使用入参 get 字段来访问输入的 Atom 和 Selector。当它访问其他 Atom 和 Selector 时，这层依赖关系会保证更新状态的同步。</p> <p>接下来我们简单的来学习使用Recoil</p> <h3 id="初始化"><a href="#初始化" aria-hidden="true" class="header-anchor">#</a> 初始化</h3> <p>使用Recoil需要使用<code>RecoilRoot</code>将组件包裹</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span>
  RecoilRoot<span class="token punctuation">,</span>
  atom<span class="token punctuation">,</span>
  selector<span class="token punctuation">,</span>
  useRecoilState<span class="token punctuation">,</span>
  useRecoilValue<span class="token punctuation">,</span>
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'recoil'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>RecoilRoot<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>CharacterCounter <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>RecoilRoot<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="订阅和更新状态"><a href="#订阅和更新状态" aria-hidden="true" class="header-anchor">#</a> 订阅和更新状态</h3> <p>Recoil 采用 Hooks 方式订阅和更新状态，常用的是下面三个 API：</p> <ul><li><code>useRecoilState</code> 类似useState的一个Hook，可以取到 atom 的值 和 setter 函数</li> <li><code>useSetRecoilState</code> 只获取setter函数 如果只使用了这个函数，状态变化不会导致组件重新渲染</li> <li><code>useRecoilValue</code> 只获取状态</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token keyword">const</span> atomKey <span class="token operator">=</span> <span class="token function">Symobl</span><span class="token punctuation">(</span><span class="token string">'atom'</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> textState <span class="token operator">=</span> <span class="token function">atom</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  key<span class="token punctuation">:</span> atomKey<span class="token punctuation">,</span> <span class="token comment">// unique ID (with respect to other atoms/selectors)</span>
  <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment">// default value (aka initial value)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">CharacterCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>TextInput <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>CharacterCount <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">TextInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>text<span class="token punctuation">,</span> setText<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useRecoilState</span><span class="token punctuation">(</span>textState<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">onChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setText</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> value<span class="token operator">=</span><span class="token punctuation">{</span>text<span class="token punctuation">}</span> onChange<span class="token operator">=</span><span class="token punctuation">{</span>onChange<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">&gt;</span>
      Echo<span class="token punctuation">:</span> <span class="token punctuation">{</span>text<span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="派生状态"><a href="#派生状态" aria-hidden="true" class="header-anchor">#</a> 派生状态</h3> <p>selector 表示一段派生状态，它使我们能够建立依赖于其他 atom 的状态。它有一个强制性的 get 函数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token keyword">const</span> selectorKey <span class="token operator">=</span> <span class="token function">Symobl</span><span class="token punctuation">(</span><span class="token string">'selector'</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> charCountState <span class="token operator">=</span> <span class="token function">selector</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  key<span class="token punctuation">:</span> selectorKey<span class="token punctuation">,</span> <span class="token comment">// unique ID (with respect to other atoms/selectors)</span>
  <span class="token function-variable function">get</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token keyword">get</span><span class="token punctuation">(</span>textState<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> text<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">CharacterCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">useRecoilValue</span><span class="token punctuation">(</span>charCountState<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>Character Count<span class="token punctuation">:</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="异步状态"><a href="#异步状态" aria-hidden="true" class="header-anchor">#</a> 异步状态</h3> <p>Recoil提供了一种通过数据流图将状态和派生状态映射到React组件的方法。真正强大的功能是图中的函数也可以是异步的。这使得在异步React组件渲染函数中轻松使用异步函数成为可能. 只需从选择器get回调中将Promise返回值，而不是返回值本身.</p> <p>例如下面的例子，如果用户名存储在我们需要查询的某个数据库中，那么我们要做的就是返回一个 Promise 或使用一个 async 函数。如果任何依赖项发生更改，则将重新评估选择器并执行新查询。结果将被缓存，因此查询将仅对每个唯一输入执行一次。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> currentUserNameQuery <span class="token operator">=</span> <span class="token function">selector</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  key<span class="token punctuation">:</span> <span class="token string">'CurrentUserName'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">get</span><span class="token punctuation">:</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">myDBQuery</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      userID<span class="token punctuation">:</span> <span class="token keyword">get</span><span class="token punctuation">(</span>currentUserIDState<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> response<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">CurrentUserInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> userName <span class="token operator">=</span> <span class="token function">useRecoilValue</span><span class="token punctuation">(</span>currentUserNameQuery<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span>userName<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Recoil 推荐使用 Suspense，Suspense 将会捕获所有异步状态，另外配合 ErrorBoundary 来进行错误捕获：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">MyApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>RecoilRoot<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ErrorBoundary<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>React<span class="token punctuation">.</span>Suspense fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>Loading<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>CurrentUserInfo <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>React<span class="token punctuation">.</span>Suspense<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ErrorBoundary<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>RecoilRoot<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>总结：上诉内容只是简单的介绍和使用了Recoil，属于入门级，需要深入的理解和项目中使用可以查看文档，和社区成熟示例</p> <p>参考资料链接：</p> <ul><li><a href="https://recoiljs.org/" target="_blank" rel="noopener noreferrer">https://recoiljs.org/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://mp.weixin.qq.com/s/OwYW9v4FooE2IK2AJQePpA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/OwYW9v4FooE2IK2AJQePpA<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="requestidlecallback"><a href="#requestidlecallback" aria-hidden="true" class="header-anchor">#</a> requestIdleCallback</h2> <h3 id="用法与说明"><a href="#用法与说明" aria-hidden="true" class="header-anchor">#</a> 用法与说明</h3> <p><code>window.requestIdleCallbacck()</code>方法将在浏览器的空闲时段内调用的函数排队。这使得开发者能够在主事件循环上执行后台和低优先级工作。、</p> <p>语法：<code>var handle = window.requestIdleCallback(callback[,options])</code></p> <p>返回值是一个ID，可以把它传入<code>window.cancelIdleCallback()</code>方法来结束回调</p> <p>参数：</p> <ol><li><p>callback 一个在事件循环空闲时即将被调用的函数引用。函数接收一个名为 IdleDeadline 的参数。该参数具有一个<code>timeRemaining()</code>方法 返回当前frame还剩多少时间和didTimeout属性用来判断当前的回调函数是否被执行。如果没有执行didTimeout属性将为ture</p></li> <li><p>options 可选
包括可选的配置参数。具有如下属性：</p></li></ol> <ul><li>timeout：如果指定了timeout并具有一个正值，并且尚未通过超时毫秒数调用回调，那么回调会在下一次空闲时期被强制执行，尽管这样很可能会对性能造成负面影响。</li></ul> <p>requestIdleCallback中可以传递{timeout: 2000}表明2s内必须调用myNonEssentialWork，如果myNonEssentialWork调用是因为timeout则didTimeout为true。</p> <p>示例：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>    <span class="token function">requestIdelCallback</span><span class="token punctuation">(</span>myNonEssentialWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    
    <span class="token keyword">function</span> <span class="token function">myNonEssentialWork</span> <span class="token punctuation">(</span><span class="token parameter">deadline</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
      <span class="token comment">// deadline.timeRemaining()可以获取到当前帧剩余时间</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> tasks<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">doWorkIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>tasks<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>myNonEssentialWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

</code></pre></div><h3 id="兼容性与缺陷"><a href="#兼容性与缺陷" aria-hidden="true" class="header-anchor">#</a> 兼容性与缺陷</h3> <blockquote><p>requestIdleCallback is called only 20 times per second - Chrome on my 6x2 core Linux machine, it's not really useful for UI work。—— from Releasing Suspense</p></blockquote> <p>requestIdleCallback 的 FPS 只有 20, 这远远低于页面流畅度的要求！(一般 FPS 为 60 时对用户来说是感觉流程的, 即一帧时间为 16.7 ms)</p> <p>requestIdleCallback 的兼容性不太好在safari中不支持</p> <h3 id="react中的polyfill版本"><a href="#react中的polyfill版本" aria-hidden="true" class="header-anchor">#</a> React中的polyfill版本</h3> <h4 id="非dom环境下"><a href="#非dom环境下" aria-hidden="true" class="header-anchor">#</a> 非DOM环境下</h4> <p>在不能操作DOM的环境下可以使用setTimeout来实现。比如node环境中</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function-variable function">requestIdleCallback</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">Infinity</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="dom环境下"><a href="#dom环境下" aria-hidden="true" class="header-anchor">#</a> DOM环境下</h4> <p>requestAnimationFrame + 计算帧时间及下一帧时间 + MessageChannel 就是我们实现 requestIdleCallback 的三个关键点了。</p> <p>但是requestAnimationFrame又一点小瑕疵。页面处于后台时该回调函数不会执行，因此我们需要对于这种情况做个补救措施</p> <p>React中当 requestAnimationFrame 不执行时，会有 setTimeout 去补救，两个定时器内部可以互相取消对方。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">ANIMATION_FRAME_TIMEOUT</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> rAFID<span class="token punctuation">;</span>
<span class="token keyword">let</span> rAFTimeoutID<span class="token punctuation">;</span>
<span class="token comment">// 调用 requestAnimationFrame, 并对执行时间超过 100 ms 的任务用 setTimeout 进行处理</span>
<span class="token keyword">const</span> <span class="token function-variable function">requestAnimationFrameWithTimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  rAFID <span class="token operator">=</span> <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">timestamp</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>rAFTimeoutID<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">callback</span><span class="token punctuation">(</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果在一帧中某个任务执行时间超过 100 ms 则终止该帧的执行并将该任务放入下一个事件队列中</span>
  rAFTimeoutID <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">cancelAnimationFrame</span><span class="token punctuation">(</span>rAFID<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token constant">ANIMATION_FRAME_TIMEOUT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>requestHostCallback(也就是 requestIdleCallback) 这部分源码的实现比较复杂, 可以将其分解为以下几个重要的步骤(有一些细节点可以看注释):</p> <ul><li><p>步骤一: 如果有优先级更高的任务, 则通过 postMessage 触发步骤四, 否则如果 requestAnimationFrame 在当前帧没有安排任务, 则开始一个帧的流程;</p></li> <li><p>步骤二: 在一个帧的流程中调用 requestAnimationFrameWithTimeout 函数, 该函数调用了 requestAnimationFrame, 并对执行时间超过 100ms 的任务用 setTimeout 放到下一个事件队列中处理;</p></li> <li><p>步骤三: 执行 requestAnimationFrame 中的回调函数 animationTick, 在该回调函数中得到当前帧的截止时间 frameDeadline, 并通过 postMessage 触发步骤四;</p></li> <li><p>步骤四: 通过 onmessage 接受 postMessage 指令, 触发消息事件的执行。在 onmessage 函数中根据 frameDeadline - currentTime &lt;= 0 判断任务是否可以在当前帧执行，如果可以的话执行该任务, 否则进入下一帧的调用。</p></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token keyword">let</span> scheduledHostCallback <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 调度器回调函数</span>
<span class="token keyword">let</span> isMessageEventScheduled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 消息事件是否执行</span>
<span class="token keyword">let</span> timeoutTime <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> isAnimationFrameScheduled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> isFlushingHostCallback <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> frameDeadline <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 当前帧的截止时间</span>

<span class="token comment">// 假设最开始的 FPS(feet per seconds) 为 30, 但这个值会随着动画帧调用的频率而动态变化</span>
<span class="token keyword">let</span> previousFrameTime <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span> <span class="token comment">// 一帧的时间: 1000 / 30 ≈ 33</span>
<span class="token keyword">let</span> activeFrameTime <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span>

<span class="token comment">// 建立通道</span>
<span class="token keyword">const</span> channel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> port <span class="token operator">=</span> channel<span class="token punctuation">.</span>port2<span class="token punctuation">;</span>


<span class="token function-variable function">shouldYieldToHost</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> frameDeadline <span class="token operator">&lt;=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function-variable function">getCurrentTime</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> performance<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">// 步骤一</span>
<span class="token function-variable function">requestHostCallback</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> absoluteTimeout</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  scheduledHostCallback <span class="token operator">=</span> callback<span class="token punctuation">;</span> <span class="token comment">// 这里的 callback 为调度器回调函数</span>
  timeoutTime <span class="token operator">=</span> absoluteTimeout<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isFlushingHostCallback <span class="token operator">||</span> absoluteTimeout <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 针对优先级较高的任务不等下一个帧，在当前帧通过 postMessage 尽快执行</span>
    port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isAnimationFrameScheduled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果 rAF 在当前帧没有安排任务, 则开始一个帧的流程</span>
    isAnimationFrameScheduled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token function">requestAnimationFrameWithTimeout</span><span class="token punctuation">(</span>animationTick<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 步骤二 上述代码requestAnimationFrameWithTimeout部门</span>


<span class="token comment">// 步骤三 requestAnimationFrame 的回调函数。传入的 rafTime 为执行该帧的时间戳。</span>
<span class="token keyword">const</span> <span class="token function-variable function">animationTick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">rafTime</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果存在调度器回调函数则在一帧的开头急切地安排下一帧的动画回调(急切是因为如果在帧的后半段安排动画回调的话, 就会增大下一帧超过 100ms 的几率, 从而会浪费一个帧的利用, 可以结合步骤②来理解这句话), 如果不存在调度器回调函数否则立马终止执行。</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>scheduledHostCallback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">requestAnimationFrameWithTimeout</span><span class="token punctuation">(</span>animationTick<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    isAnimationFrameScheduled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> nextFrameTime <span class="token operator">=</span> rafTime <span class="token operator">-</span> frameDeadline <span class="token operator">+</span> activeFrameTime<span class="token punctuation">;</span> <span class="token comment">// 当前帧开始调用动画的时间 - 上一帧调用动画的截止时间 + 当前帧执行的时间，这里的 nextFrameTime 仅仅是临时变量</span>
  <span class="token comment">// 如果连续两帧的时间都小于当前帧的时间, 则说明得调高 FPS</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFrameTime <span class="token operator">&lt;</span> activeFrameTime <span class="token operator">&amp;&amp;</span> previousFrameTime <span class="token operator">&lt;</span> activeFrameTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将 activeFrameTime 的值减小相当于调高 FPS。同时取 nextFrameTime 与 previousFrameTime 中较大的一个以让前后两帧都不出问题。</span>
    activeFrameTime <span class="token operator">=</span> nextFrameTime <span class="token operator">&lt;</span> previousFrameTime <span class="token operator">?</span> previousFrameTime <span class="token punctuation">:</span> nextFrameTime<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    previousFrameTime <span class="token operator">=</span> nextFrameTime<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  frameDeadline <span class="token operator">=</span> rafTime <span class="token operator">+</span> activeFrameTime<span class="token punctuation">;</span> <span class="token comment">// 当前帧的截止时间(上面几行代码的目的是得到该 frameDeadline 值, 该值在 postMessage 会用来判断)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isMessageEventScheduled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    isMessageEventScheduled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 最后进入第④步, 通过 postMessage 触发消息事件。</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>



<span class="token comment">// 步骤四  接受 `postMessage` 指令, 触发消息事件的执行。在其中判断任务是否在当前帧执行，如果在的话执行该任务</span>
channel<span class="token punctuation">.</span>port1<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  isMessageEventScheduled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> prevScheduledCallback <span class="token operator">=</span> scheduledHostCallback<span class="token punctuation">;</span>
  <span class="token keyword">const</span> prevTimeoutTime <span class="token operator">=</span> timeoutTime<span class="token punctuation">;</span>
  scheduledHostCallback <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  timeoutTime <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> currentTime <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> didTimeout <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 是否超时</span>
  <span class="token comment">// 如果当前帧已经没有时间剩余, 检查是否有 timeout 参数，如果有的话是否已经超过这个时间</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>frameDeadline <span class="token operator">-</span> currentTime <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevTimeoutTime <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> prevTimeoutTime <span class="token operator">&lt;=</span> currentTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// didTimeout 为 true 后, 在当前帧中执行(针对优先级较高的任务)</span>
      didTimeout <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 在下一帧中执行</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isAnimationFrameScheduled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        isAnimationFrameScheduled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token function">requestAnimationFrameWithTimeout</span><span class="token punctuation">(</span>animationTick<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      scheduledHostCallback <span class="token operator">=</span> prevScheduledCallback<span class="token punctuation">;</span>
      timeoutTime <span class="token operator">=</span> prevTimeoutTime<span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevScheduledCallback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    isFlushingHostCallback <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token function">prevScheduledCallback</span><span class="token punctuation">(</span>didTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
      isFlushingHostCallback <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 取消</span>
<span class="token function-variable function">cancelHostCallback</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  scheduledHostCallback <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  isMessageEventScheduled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  timeoutTime <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="requestanimationframe"><a href="#requestanimationframe" aria-hidden="true" class="header-anchor">#</a> requestAnimationFrame</h2> <p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</p> <h3 id="语法"><a href="#语法" aria-hidden="true" class="header-anchor">#</a> 语法</h3> <p><code>window.requestAnimationFrame(callback)</code></p> <p>该callback会被传入DOMHighResTimeStamp参数，该参数与performance.now()的返回值相同，它表示requestAnimationFrame() 开始去执行回调函数的时刻。</p> <h3 id="缺陷"><a href="#缺陷" aria-hidden="true" class="header-anchor">#</a> 缺陷</h3> <p>为了提高性能和电池寿命，因此在大多数浏览器里，当requestAnimationFrame() 运行在后台标签页或者隐藏的<code>&lt;iframe&gt;</code> 里时，<code>requestAnimationFrame()</code> 会被暂停调用以提升性能和电池寿命。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/network.html" class="prev">
          网络
        </a></span> <span class="next"><a href="/webpack.html">
          Webpack
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.94b2f3ef.js" defer></script><script src="/assets/js/2.d467c8ee.js" defer></script><script src="/assets/js/7.4250d63b.js" defer></script>
  </body>
</html>

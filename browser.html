<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器系列 | FE Knowledge</title>
    <meta name="description" content="前端知识点梳理">
    
    
    <link rel="preload" href="/assets/css/0.styles.b194f207.css" as="style"><link rel="preload" href="/assets/js/app.94b2f3ef.js" as="script"><link rel="preload" href="/assets/js/2.d467c8ee.js" as="script"><link rel="preload" href="/assets/js/5.d198a837.js" as="script"><link rel="prefetch" href="/assets/js/10.7358a0a7.js"><link rel="prefetch" href="/assets/js/11.b76e3d06.js"><link rel="prefetch" href="/assets/js/12.a146812a.js"><link rel="prefetch" href="/assets/js/13.cf5c1852.js"><link rel="prefetch" href="/assets/js/14.c5690a9e.js"><link rel="prefetch" href="/assets/js/15.cfd708ec.js"><link rel="prefetch" href="/assets/js/16.667fb96d.js"><link rel="prefetch" href="/assets/js/17.09141bb2.js"><link rel="prefetch" href="/assets/js/18.65cc8cb4.js"><link rel="prefetch" href="/assets/js/19.742f92d8.js"><link rel="prefetch" href="/assets/js/20.93f5ef9b.js"><link rel="prefetch" href="/assets/js/21.bf458488.js"><link rel="prefetch" href="/assets/js/3.64e9b869.js"><link rel="prefetch" href="/assets/js/4.e7adceac.js"><link rel="prefetch" href="/assets/js/6.eee8a3aa.js"><link rel="prefetch" href="/assets/js/7.4250d63b.js"><link rel="prefetch" href="/assets/js/8.c395ce89.js"><link rel="prefetch" href="/assets/js/9.10bd2809.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b194f207.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">FE Knowledge</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/lewisYe" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/lewisYe" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/introduction.html" class="sidebar-link">介绍</a></li><li><a href="/html.html" class="sidebar-link">HTML</a></li><li><a href="/css.html" class="sidebar-link">CSS</a></li><li><a href="/js_base.html" class="sidebar-link">JS 基础</a></li><li><a href="/js_advanced.html" class="sidebar-link">手写JS</a></li><li><a href="/es6.html" class="sidebar-link">ES6</a></li><li><a href="/browser.html" class="active sidebar-link">浏览器系列</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/browser.html#浏览器内核" class="sidebar-link">浏览器内核</a></li><li class="sidebar-sub-header"><a href="/browser.html#浏览器架构" class="sidebar-link">浏览器架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/browser.html#进程和线程" class="sidebar-link">进程和线程</a></li><li class="sidebar-sub-header"><a href="/browser.html#浏览器的多进程架构" class="sidebar-link">浏览器的多进程架构</a></li></ul></li><li class="sidebar-sub-header"><a href="/browser.html#浏览器渲染机制" class="sidebar-link">浏览器渲染机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/browser.html#构建dom树" class="sidebar-link">构建DOM树</a></li><li class="sidebar-sub-header"><a href="/browser.html#样式计算（recalculate-style）" class="sidebar-link">样式计算（Recalculate Style）</a></li><li class="sidebar-sub-header"><a href="/browser.html#布局阶段" class="sidebar-link">布局阶段</a></li><li class="sidebar-sub-header"><a href="/browser.html#分层" class="sidebar-link">分层</a></li><li class="sidebar-sub-header"><a href="/browser.html#图层绘制" class="sidebar-link">图层绘制</a></li><li class="sidebar-sub-header"><a href="/browser.html#栅格化（raster）操作" class="sidebar-link">栅格化（raster）操作</a></li><li class="sidebar-sub-header"><a href="/browser.html#合成与显示" class="sidebar-link">合成与显示</a></li><li class="sidebar-sub-header"><a href="/browser.html#渲染流水线总结" class="sidebar-link">渲染流水线总结</a></li><li class="sidebar-sub-header"><a href="/browser.html#重排、重绘、合成" class="sidebar-link">重排、重绘、合成</a></li><li class="sidebar-sub-header"><a href="/browser.html#load-和-domcontentloaded-区别" class="sidebar-link">Load 和 DOMContentLoaded 区别</a></li><li class="sidebar-sub-header"><a href="/browser.html#js对dom、cssom构建的影响" class="sidebar-link">JS对DOM、CSSOM构建的影响</a></li></ul></li><li class="sidebar-sub-header"><a href="/browser.html#垃圾回收机制" class="sidebar-link">垃圾回收机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/browser.html#数据的存储" class="sidebar-link">数据的存储</a></li><li class="sidebar-sub-header"><a href="/browser.html#垃圾数据如何回收" class="sidebar-link">垃圾数据如何回收</a></li><li class="sidebar-sub-header"><a href="/browser.html#垃圾回收器的工作流程" class="sidebar-link">垃圾回收器的工作流程</a></li><li class="sidebar-sub-header"><a href="/browser.html#全停顿" class="sidebar-link">全停顿</a></li></ul></li><li class="sidebar-sub-header"><a href="/browser.html#跨域" class="sidebar-link">跨域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/browser.html#跨域的产生" class="sidebar-link">跨域的产生</a></li><li class="sidebar-sub-header"><a href="/browser.html#跨域的解决" class="sidebar-link">跨域的解决</a></li></ul></li><li class="sidebar-sub-header"><a href="/browser.html#本地存储" class="sidebar-link">本地存储</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/browser.html#cookies" class="sidebar-link">cookies</a></li><li class="sidebar-sub-header"><a href="/browser.html#localstorage、sessionstorage" class="sidebar-link">localStorage、sessionStorage</a></li><li class="sidebar-sub-header"><a href="/browser.html#三者区别" class="sidebar-link">三者区别</a></li><li class="sidebar-sub-header"><a href="/browser.html#service-worker" class="sidebar-link">Service Worker</a></li></ul></li><li class="sidebar-sub-header"><a href="/browser.html#浏览器安全" class="sidebar-link">浏览器安全</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/browser.html#xss" class="sidebar-link">XSS</a></li><li class="sidebar-sub-header"><a href="/browser.html#csrf" class="sidebar-link">CSRF</a></li><li class="sidebar-sub-header"><a href="/browser.html#jwt" class="sidebar-link">JWT</a></li><li class="sidebar-sub-header"><a href="/browser.html#sso" class="sidebar-link">SSO</a></li></ul></li><li class="sidebar-sub-header"><a href="/browser.html#浏览器缓存" class="sidebar-link">浏览器缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/browser.html#强制缓存" class="sidebar-link">强制缓存</a></li><li class="sidebar-sub-header"><a href="/browser.html#协商缓存" class="sidebar-link">协商缓存</a></li><li class="sidebar-sub-header"><a href="/browser.html#缓存总结" class="sidebar-link">缓存总结</a></li><li class="sidebar-sub-header"><a href="/browser.html#实际项目中的缓存问题" class="sidebar-link">实际项目中的缓存问题</a></li></ul></li><li class="sidebar-sub-header"><a href="/browser.html#chrome-devtools" class="sidebar-link">Chrome DevTools</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/browser.html#elements" class="sidebar-link">Elements</a></li><li class="sidebar-sub-header"><a href="/browser.html#console" class="sidebar-link">Console</a></li><li class="sidebar-sub-header"><a href="/browser.html#sources" class="sidebar-link">Sources</a></li><li class="sidebar-sub-header"><a href="/browser.html#netwrok" class="sidebar-link">Netwrok</a></li><li class="sidebar-sub-header"><a href="/browser.html#performance" class="sidebar-link">Performance</a></li></ul></li></ul></li><li><a href="/network.html" class="sidebar-link">网络</a></li><li><a href="/react.html" class="sidebar-link">React</a></li><li><a href="/webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/ts.html" class="sidebar-link">TypeScript</a></li><li><a href="/performance.html" class="sidebar-link">性能</a></li><li><a href="/algorithm.html" class="sidebar-link">数据结构与算法</a></li><li><a href="/design.html" class="sidebar-link">设计模式</a></li><li><a href="/other.html" class="sidebar-link">其它</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="浏览器系列"><a href="#浏览器系列" aria-hidden="true" class="header-anchor">#</a> 浏览器系列</h1> <h2 id="浏览器内核"><a href="#浏览器内核" aria-hidden="true" class="header-anchor">#</a> 浏览器内核</h2> <table><thead><tr><th style="text-align:center;">浏览器/RunTime</th> <th style="text-align:center;">内核（渲染引擎）</th> <th style="text-align:center;">JavaScript 引擎</th></tr></thead> <tbody><tr><td style="text-align:center;">Chrome</td> <td style="text-align:center;">Blink（28~）Webkit（Chrome 27）</td> <td style="text-align:center;">V8</td></tr> <tr><td style="text-align:center;">FireFox</td> <td style="text-align:center;">Gecko</td> <td style="text-align:center;">SpiderMonkey</td></tr> <tr><td style="text-align:center;">Safari</td> <td style="text-align:center;">Webkit</td> <td style="text-align:center;">JavaScriptCore</td></tr> <tr><td style="text-align:center;">Edge</td> <td style="text-align:center;">EdgeHTML</td> <td style="text-align:center;">Chakra(for JavaScript)</td></tr> <tr><td style="text-align:center;">IE</td> <td style="text-align:center;">Trident</td> <td style="text-align:center;">Chakra(for JScript)</td></tr> <tr><td style="text-align:center;">Node.js</td> <td style="text-align:center;">-</td> <td style="text-align:center;">Node.js</td></tr></tbody></table> <h2 id="浏览器架构"><a href="#浏览器架构" aria-hidden="true" class="header-anchor">#</a> 浏览器架构</h2> <p>本文介绍的浏览器架构是基于Chrome浏览器的。</p> <p>在这之前先理解什么是进程和线程</p> <h3 id="进程和线程"><a href="#进程和线程" aria-hidden="true" class="header-anchor">#</a> 进程和线程</h3> <p><strong>线程</strong></p> <p>线程：CPU调度的最小单位</p> <p>线程有单线程、多线程之分。多线程可以并行处理提高性能。</p> <p>线程不能单独存在的，它是由进程来启动和管理。</p> <p><strong>进程</strong></p> <p>进程：CPU进行资源分配的基本单位</p> <p>一个进程就是一个程序的运行实例。</p> <p>详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。</p> <p><strong>总结</strong></p> <p>比喻加深理解 进程=火车，线程=车厢</p> <ul><li>线程在进程下运行（车厢组成火车，单独车厢无法运行）</li> <li>一个进程可以包含多线程（一辆火车有多节车厢）</li> <li>不同进程之间数据很难共享（一辆火车换乘到另一辆是比较麻烦的）</li> <li>同一进程下不同线程数据易共享（车厢之间更换还是简便的）</li> <li>进程要比线程消耗更多的计算机资源（采用多列火车比采用多节车厢耗费资源）</li> <li>进程间互相不影响，一个线程挂掉将导致整个进程挂掉（火车与火车间互不性影响，但比如一节车厢着火会影响整辆火车）</li> <li>进程可以拓展到多机，进程最多适合多核 （不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</li> <li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－&quot;互斥锁&quot;</li> <li>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</li></ul> <h3 id="浏览器的多进程架构"><a href="#浏览器的多进程架构" aria-hidden="true" class="header-anchor">#</a> 浏览器的多进程架构</h3> <p>浏览器的发展也是从最开始的单进程发展到目前的多进程架构</p> <h4 id="浏览器单进程时代"><a href="#浏览器单进程时代" aria-hidden="true" class="header-anchor">#</a> 浏览器单进程时代</h4> <p>顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。其实早在 2007 年之前，市面上浏览器都是单进程的。</p> <p>如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。下面我就来一一分析下出现这些问题的原因。</p> <ol><li>不稳定</li></ol> <p>早期浏览器需要借助于插件来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃</p> <ol start="2"><li>不流畅</li></ol> <p>页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。</p> <p>如果有一个脚本是无限循环的，所以当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行</p> <ol start="3"><li>不安全</li></ol> <p>插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</p> <p>至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</p> <p>目前的Chrome进程架构，如下图所示</p> <p><img src="/assets/img/chromeprocess.b61cab52.png" alt=""></p> <p>从图中可以看出，最新的Chrome 浏览器包括：1个浏览器主进程、1个GPU进程、1个网络进程、多个渲染进程和多个插件进程。</p> <ul><li><strong>浏览器进程</strong> 主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。</li> <li><strong>渲染进程</strong> 核心任务是将HTML、CSS和JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li> <li><strong>GPU进程</strong> 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li> <li><strong>网络进程</strong> 主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li> <li><strong>插件进程</strong> 主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul> <p>这个就是为什么打开一个页面，需要有4个进程。因为打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p> <p>你可以点击 Chrome 浏览器右上角的“选项”菜单，选择“更多工具”子菜单，点击“任务管理器”，就可以查看到进程信息。</p> <h2 id="浏览器渲染机制"><a href="#浏览器渲染机制" aria-hidden="true" class="header-anchor">#</a> 浏览器渲染机制</h2> <p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示：
<img src="/assets/img/BrowserRender.9259f873.png" alt=""></p> <p>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。</p> <p>在介绍每个阶段的过程中，你应该重点关注以下三点内容：</p> <ol><li>开始每个子阶段都有其输入的内容</li> <li>然后每个子阶段有其处理过程；</li> <li>最终每个子阶段会生成输出内容。</li></ol> <h3 id="构建dom树"><a href="#构建dom树" aria-hidden="true" class="header-anchor">#</a> 构建DOM树</h3> <p>因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。</p> <p><img src="/assets/img/domtree1.125849ec.png" alt=""></p> <p>构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。</p> <p>为了更加直观地理解 DOM 树，你可以打开 Chrome 的“开发者工具”，选择“Console”标签来打开控制台，然后在控制台里面输入“document”后回车，这样你就能看到一个完整的 DOM 树结构</p> <p>DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。</p> <h4 id="html解析器"><a href="#html解析器" aria-hidden="true" class="header-anchor">#</a> HTML解析器</h4> <p>从后端返回给浏览器渲染引擎 HTML 文件字节流，HTML 文件字节流返回的过程中 HTML 解析器就一直在解析，边加载边解析。</p> <h5 id="阶段一-字节流转换为字符并w3c标准令牌化"><a href="#阶段一-字节流转换为字符并w3c标准令牌化" aria-hidden="true" class="header-anchor">#</a> 阶段一 字节流转换为字符并W3C标准令牌化</h5> <p>读取HTML的原始字节流，并根据文件的指定编码（例如UTF-8）将它们转换成各个字符。并将字符串转换成W3C HTML5标准规定的各种令牌。每个令牌都具有特殊含义和一组规则。</p> <p>一堆字节流 bytes</p> <p><code>3C 2B 1A</code></p> <p>转换成正常的html文件</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>hi <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>ye<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h5 id="阶段二-通过分词器将字节流转化为-token"><a href="#阶段二-通过分词器将字节流转化为-token" aria-hidden="true" class="header-anchor">#</a> 阶段二 通过分词器将字节流转化为 Token</h5> <p>分词器将字节流转换为一个一个的Token，Token分为Tag Token和文本Token，上面这段代码最后分词转化的结果是：
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAoAAABJCAIAAAA7RVOqAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGxGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjAtMTAtMTVUMTU6NDA6NDIrMDg6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIwLTEwLTE1VDE1OjQzOjE0KzA4OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDIwLTEwLTE1VDE1OjQzOjE0KzA4OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgSUVDNjE5NjYtMi4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjJkNjVjOTEzLWQ5YjItNGZiYi1iNmNiLTc5MmNmMTMzYTA4ZSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDphYWE2NTg1OC1lMzhkLTRlMjgtOTc5Ni1iN2FiMWQxNWFhODYiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphYWE2NTg1OC1lMzhkLTRlMjgtOTc5Ni1iN2FiMWQxNWFhODYiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmFhYTY1ODU4LWUzOGQtNGUyOC05Nzk2LWI3YWIxZDE1YWE4NiIgc3RFdnQ6d2hlbj0iMjAyMC0xMC0xNVQxNTo0MDo0MiswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKE1hY2ludG9zaCkiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjAzNDY3OTkzLTk4YzYtNDdiZS04NDE5LTNjZWNhMzYwY2IxOCIgc3RFdnQ6d2hlbj0iMjAyMC0xMC0xNVQxNTo0MzoxMSswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjJkNjVjOTEzLWQ5YjItNGZiYi1iNmNiLTc5MmNmMTMzYTA4ZSIgc3RFdnQ6d2hlbj0iMjAyMC0xMC0xNVQxNTo0MzoxNCswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+TJ/gUgAA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" alt=""></p> <h5 id="阶段三-token解析为dom节点"><a href="#阶段三-token解析为dom节点" aria-hidden="true" class="header-anchor">#</a> 阶段三 Token解析为DOM节点</h5> <p>HTML解析器维护了一个Token栈结构，这个栈结构的目的就是用来计算节点间的父子关系。具体规则如下：</p> <ul><li>HTML解析器开始工作时，会默认创建一个根为document的空DOM结构，同时会将一个StartTag document的Token压入栈底。</li></ul> <p><img src="/assets/img/tokenStack1.546f882c.png" alt=""></p> <ul><li>如果压入栈中的是startTagToken类型，HTML解析器会为该Token创建一个DOM节点，然后将该节点加入到DOM树种，它的父节点为栈中相邻元素生成的DOM节点。</li></ul> <p><img src="/assets/img/tokenStack2.c64e15b2.png" alt=""></p> <ul><li>如果是文本Token，那么会直接生成一个文件节点，加入到DOM树种，不需要入栈。它的父节点就是当前栈顶对应的DOM节点</li></ul> <p><img src="/assets/img/tokenStack3.7954c86c.png" alt=""></p> <ul><li><p>如果解析到了endTag标签，则会比较栈顶是否为对应的tag标签。如果是则对应的startTag会出栈，表示该元素解析完成。</p></li> <li><p>然后如上的规则，分词器一路解析，就形成了简单的DOM树。</p></li></ul> <h3 id="样式计算（recalculate-style）"><a href="#样式计算（recalculate-style）" aria-hidden="true" class="header-anchor">#</a> 样式计算（Recalculate Style）</h3> <p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。</p> <ol><li>把 CSS 转换为浏览器能够理解的结构</li></ol> <p>CSS 样式来源主要有三种：</p> <ul><li>通过 link 引用的外部 CSS 文件</li> <li><code>&lt;style&gt;</code>标记内的 CSS</li> <li>元素的 style 属性内嵌的 CSS</li></ul> <p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以<strong>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets</strong>。</p> <p>在控制台中输入 document.styleSheets可以查看。</p> <ol start="2"><li>转换样式表中的属性值，使其标准化</li></ol> <p>现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。</p> <p>什么是标准化呢，就是将所有值转换为渲染引擎容易理解的、标准化的计算值。</p> <ol start="3"><li>计算出 DOM 树中每个节点的具体样式</li></ol> <p>这步涉及到 CSS 的继承规则和层叠规则。</p> <p>CSS 继承就是每个 DOM 节点都包含有父节点的样式</p> <p>层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点</p> <p>这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。</p> <p>如果你想了解每个 DOM 元素最终的计算样式，可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签，如下图所示：</p> <p><img src="/assets/img/computed.d87415b0.png" alt=""></p> <h3 id="布局阶段"><a href="#布局阶段" aria-hidden="true" class="header-anchor">#</a> 布局阶段</h3> <p>Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</p> <p><strong>1. 创建布局树</strong></p> <p>你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。</p> <p>我们结合下图来看看布局树的构造过程:
<img src="/assets/img/layout.8e48b77d.png" alt=""></p> <p>从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中。</p> <p>为了构建布局树，浏览器大体上完成了下面这些工作：</p> <ul><li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；</li> <li>而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。</li></ul> <p><strong>2. 布局计算</strong></p> <h3 id="分层"><a href="#分层" aria-hidden="true" class="header-anchor">#</a> 分层</h3> <p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）</p> <p>要想直观地理解什么是图层，你可以打开 Chrome 的“开发者工具”，选择右上角三个点 选中的more tools 选择“Layers”标签，就可以可视化页面的分层情况</p> <p>会发现浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。</p> <p>下面来看看这些图层和布局树节点之间的关系，如文中图所示：</p> <p><img src="/assets/img/layertree.e8a7e60a.png" alt=""></p> <p>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</p> <p>那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</p> <ol><li>拥有层叠上下文属性的元素会被提升为单独的一层</li></ol> <p>页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上</p> <p>若你想要了解更多层叠上下文的知识，你可以<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener noreferrer">参考这篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <ol start="2"><li>需要剪裁（clip）的地方也会被创建为图层。</li></ol> <p>那什么是裁剪呢</p> <p>比如我们把一个 div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁</p> <p>出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层</p> <p>所以说，元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。</p> <h3 id="图层绘制"><a href="#图层绘制" aria-hidden="true" class="header-anchor">#</a> 图层绘制</h3> <p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制</p> <p>渲染引擎实现图层的绘制，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表</p> <p>你可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表，如下图所示：
<img src="/assets/img/draw.303515c2.png" alt="">
在该图中，区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。</p> <h3 id="栅格化（raster）操作"><a href="#栅格化（raster）操作" aria-hidden="true" class="header-anchor">#</a> 栅格化（raster）操作</h3> <p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的</p> <p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p> <p>基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512。如下图所示：</p> <p><img src="/assets/img/raster.bcc7f698.png" alt=""></p> <p>然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图.</p> <p>而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的.通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p> <p><img src="/assets/img/gpuraster.a8d954cd.png" alt=""></p> <h3 id="合成与显示"><a href="#合成与显示" aria-hidden="true" class="header-anchor">#</a> 合成与显示</h3> <p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p> <p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p> <p>到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。</p> <h3 id="渲染流水线总结"><a href="#渲染流水线总结" aria-hidden="true" class="header-anchor">#</a> 渲染流水线总结</h3> <p>用一张图来总结下这整个渲染流程：</p> <p><img src="/assets/img/renderfinally.975fcbf7.png" alt=""></p> <ol><li>渲染进程将HTML内容转换为浏览器能够读懂的<strong>DOM树</strong>结构</li> <li>渲染引擎将CSS样式表转化为浏览器可以理解的<strong>styleSheets</strong>,计算出DOM节点的样式</li> <li>创建<strong>布局树</strong>,并计算元素的布局信息</li> <li>对布局树进行分层，并生成<strong>分层树</strong></li> <li>为每个图层生成<strong>绘制列表</strong>，并将其提交到合成线程</li> <li>合成线程将图层分成<strong>图块</strong>，并在<strong>光栅化线程池</strong>中将图块转换成位图</li> <li>合成线程发送绘制图块命令<strong>DrawQuad</strong>给浏览器进程</li> <li>浏览器进程根据DrawQuad消息<strong>生成页面</strong>，并<strong>显示</strong>到显示器上</li></ol> <h3 id="重排、重绘、合成"><a href="#重排、重绘、合成" aria-hidden="true" class="header-anchor">#</a> 重排、重绘、合成</h3> <ol><li>更新了元素的几何属性（重排）</li></ol> <p>你可先参考下图:</p> <p><img src="/assets/img/repaint.b3ed5652.png" alt=""></p> <p>从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫<strong>重排</strong>。无疑，<strong>重排需要更新完整的渲染流水线，所以开销也是最大的</strong>。</p> <ol start="2"><li>更新元素的绘制属性（重绘）</li></ol> <p>比如通过 JavaScript 更改某些元素的背景颜色，渲染流水线会调整为如下图：</p> <p><img src="/assets/img/reflow.3c1b7310.png" alt=""></p> <p>从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫<strong>重绘</strong>。相较于重排操作，<strong>重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些</strong>。</p> <ol start="3"><li>直接合成阶段</li></ol> <p>那如果你更改一个既不要布局也不要绘制的属性，那么渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。具体流程参考下图：</p> <p><img src="/assets/img/compose.024bf6c8.png" alt=""></p> <p>在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，<strong>所以相对于重绘和重排，合成能大大提升绘制效率</strong>。</p> <h4 id="减少重排与重绘"><a href="#减少重排与重绘" aria-hidden="true" class="header-anchor">#</a> 减少重排与重绘</h4> <ul><li>使用 class 操作样式，而不是频繁操作 style</li> <li>避免使用 table 布局</li> <li>Debounce window resize 事件</li> <li>对 dom 属性的读写要分离</li> <li>will-change: transform 做优化</li> <li>批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React</li></ul> <p>我们可以通过createDocumentFragment创建一个游离于DOM树之外的节点，然后在此节点上批量操作，最后插入DOM树中，因此只触发一次重排</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> fragment <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;p&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  node<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> i<span class="token punctuation">;</span>
  fragment<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>设备刷新率是设备屏幕渲染的频率60HZ 也就是屏幕在1s内渲染60次，约16.7ms渲染一次屏幕。这就意味着，我们的浏览器最佳的渲染性能就是所有的操作在一帧16.7ms内完成。</p> <h3 id="load-和-domcontentloaded-区别"><a href="#load-和-domcontentloaded-区别" aria-hidden="true" class="header-anchor">#</a> Load 和 DOMContentLoaded 区别</h3> <p>Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。</p> <p>DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载\</p> <h3 id="js对dom、cssom构建的影响"><a href="#js对dom、cssom构建的影响" aria-hidden="true" class="header-anchor">#</a> JS对DOM、CSSOM构建的影响</h3> <p>分为三种情况。</p> <ol><li>页面中只有HTML和JS，且JS不是外部引入</li></ol> <p>DOM 树构建时当遇到JavaScript脚本，就要暂停 DOM 解析，先去执行Javascript，因为在JavaScript可能会操作当前已经生成的DOM节点。</p> <p>有一点需要注意:javascript是可能操作当前已经生成的DOM节点，如果是后面还未生成的DOM节点是不生效的</p> <ol start="2"><li>当页面中同时有Html、JavaScript、CSS ，而且都非外部引入。</li></ol> <p>DOM 树构建时当遇到 JavaScript 脚本，就要暂停 DOM 解析，先去执行 JavaScript，同时 JavaScript 还要判断 CSSOM 是否解析完成，因为在 JavaScript 可能会操作 CSSOM 节点，CSSOM 节点确认解析完成，执行 JavaScript 再次回到 DOM 树创建。（所以这里也可以理解为CSS解析间接影响DOM树创建）</p> <ol start="3"><li>当页面中同时有Html，JavaScript， CSS ，而且外部引入</li></ol> <p>Webkit渲染引擎有一个优化，当渲染进程接收HTML文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。DOM树在创建过程中如果遇到JavaScript文件，接下来就和情况2类型一样了。</p> <h2 id="垃圾回收机制"><a href="#垃圾回收机制" aria-hidden="true" class="header-anchor">#</a> 垃圾回收机制</h2> <p>在了解垃圾回收机制之前先了解数据是如何存储的。</p> <h3 id="数据的存储"><a href="#数据的存储" aria-hidden="true" class="header-anchor">#</a> 数据的存储</h3> <p>在JavaScript 的执行过程中，主要有三种类型内存空间：<strong>代码空间</strong>、<strong>栈空间</strong>、<strong>堆空间</strong></p> <p>其中的代码空间主要是存储可执行代码；栈空间就是我们之前反复提及的调用栈，是用来存储执行上下文的；对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址。</p> <h3 id="垃圾数据如何回收"><a href="#垃圾数据如何回收" aria-hidden="true" class="header-anchor">#</a> 垃圾数据如何回收</h3> <p>什么是垃圾数据呢。有些数据被使用之后，可能就不在需要了，这种数据称为垃圾数据。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要对这些垃圾数据进行回收，以释放有限的内存空间。</p> <p>通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。JS中是自动回收策略</p> <h4 id="调用栈中的垃圾数据回收"><a href="#调用栈中的垃圾数据回收" aria-hidden="true" class="header-anchor">#</a> 调用栈中的垃圾数据回收</h4> <p>在调用栈中有一个记录当前执行状态的指针（称为ESP），指向调用栈中当前正在执行的上下文。当当前函数被执行完成，JS会将ESP下移到下一个函数执行上下文。这个下移操作就是销毁一个执行上下文的过程。因为之前的执行上下文虽然还是保存在栈内存中，但是已经是无效内存，会被之后的内容所覆盖。</p> <p>所以说，当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。</p> <h4 id="堆中的垃圾数据回收"><a href="#堆中的垃圾数据回收" aria-hidden="true" class="header-anchor">#</a> 堆中的垃圾数据回收</h4> <p>要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。</p> <p>在此之前需要了解一个<code>代际假说(The Generational Hypothesis)</code>的概念。</p> <p><strong>代际假说</strong>有以下两个特点：</p> <ul><li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问。</li> <li>第二个是不死的对象，会活得更久</li></ul> <p>通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。</p> <p>V8的垃圾回收策略主要是基于<strong>分代式垃圾回收机制</strong>，其根据对象的<strong>存活时间</strong>将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。</p> <p>新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p> <ul><li>副垃圾回收器，主要负责新生代的垃圾回收。</li> <li>主垃圾回收器，主要负责老生代的垃圾回收。</li></ul> <h3 id="垃圾回收器的工作流程"><a href="#垃圾回收器的工作流程" aria-hidden="true" class="header-anchor">#</a> 垃圾回收器的工作流程</h3> <p>不论什么类型的垃圾回收器，它们都有一套共同的执行流程。</p> <ul><li>标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</li> <li>回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</li> <li>内存整理 频繁回收对象后，内存中就会存在大量不连续空间，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片</li></ul> <h4 id="副垃圾回收器"><a href="#副垃圾回收器" aria-hidden="true" class="header-anchor">#</a> 副垃圾回收器</h4> <p>副垃圾回收器，主要负责新生代的垃圾回收。新生代中用 <strong>Scavenge 算法</strong>来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：</p> <p><img src="/assets/img/Scavenge.4f9310c7.png" alt=""></p> <p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p> <p>垃圾对象的回收操作</p> <ol><li>首先要对对象区域中的垃圾做标记；</li> <li>标记完成之后，就进入垃圾清理阶段，</li> <li>副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，</li> <li>完成复制后，对象区域与空闲区域进行角色翻转,也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域</li></ol> <p>新生区的空间会被设置得比较小,是因为由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本。空间大的话 时间就会过很久。</p> <p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象<strong>晋升策略</strong>，存活时间久的对象会被移动到老生区中。</p> <p>对象晋升的条件主要有以下两个：</p> <p>1.对象是否经历过一次Scavenge算法
2.To空间的内存占比是否已经超过25%</p> <h4 id="主垃圾回收器"><a href="#主垃圾回收器" aria-hidden="true" class="header-anchor">#</a> 主垃圾回收器</h4> <p>主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p> <p>主垃圾回收器是采用<strong>标记-清除Mark-Sweep</strong>的算法进行垃圾回收的</p> <p>工作流程：</p> <ol><li>首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</li> <li>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：
<img src="/assets/img/marksweep.d015db8a.png" alt=""></li></ol> <p>上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——<strong>标记-整理 Mark-Compact</strong>这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：
<img src="/assets/img/markcompact.652bd2df.png" alt=""></p> <h3 id="全停顿"><a href="#全停顿" aria-hidden="true" class="header-anchor">#</a> 全停顿</h3> <p>现在你知道了 V8 是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p> <p>比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：
<img src="/assets/img/stoptheword.9898646a.png" alt=""></p> <p>在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。</p> <p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。如下图所示：
<img src="/assets/img/stoptheword2.de117fc9.png" alt=""></p> <p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p> <h2 id="跨域"><a href="#跨域" aria-hidden="true" class="header-anchor">#</a> 跨域</h2> <h3 id="跨域的产生"><a href="#跨域的产生" aria-hidden="true" class="header-anchor">#</a> 跨域的产生</h3> <p>因为浏览器有一种安全机制叫做同源策略。</p> <p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指&quot;协议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p> <p>同源策略限制内容有：</p> <ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容</li> <li>DOM 节点</li> <li>AJAX 请求发送后，结果被浏览器拦截了</li></ul> <p>以下三个标签可以不受限制：</p> <ul><li><code>&lt;img src=XXX&gt;</code></li> <li><code>&lt;link href=XXX&gt;</code></li> <li><code>&lt;script src=XXX&gt;</code></li></ul> <h3 id="跨域的解决"><a href="#跨域的解决" aria-hidden="true" class="header-anchor">#</a> 跨域的解决</h3> <h4 id="jsonp"><a href="#jsonp" aria-hidden="true" class="header-anchor">#</a> JSONP</h4> <p>JSONP 是 JSON with padding的简写. JSONP本质上是一个Hack，它利用<code>&lt;script&gt;</code>标签不受同源策略限制的特性进行跨域操作。由两部分组成:回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调 函数的名字一般是在请求中指定的。而数据是被放入到回调函数的参数中。下面是一个典型的 JSONP 请求。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;http://domain/api?callback=jsonp&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><p>优点：</p> <ol><li>实现简单</li> <li>兼容性非常好</li></ol> <p>缺点：</p> <ol><li>只支持get请求（因为<code>&lt;script&gt;</code>标签只能get）</li> <li>有安全性问题，可能会遭受XSS攻击</li> <li>需要服务端配合jsonp进行一定程度的改造</li></ol> <h4 id="cors"><a href="#cors" aria-hidden="true" class="header-anchor">#</a> CORS</h4> <p>跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。</p> <p>CORS 需要浏览器和后端同时支持。服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。</p> <p>cors 中会有 <code>简单请求</code> 和 <code>复杂请求</code> 的概念</p> <ol><li>简单请求</li></ol> <p>不会触发 CORS 预检请求。这样的请求为“简单请求”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”：</p> <p>情况一: 使用以下方法(意思就是以下请求以外的都是非简单请求)</p> <ul><li>GET</li> <li>HEAD</li> <li>POST</li></ul> <p>情况二: 人为设置以下集合外的请求头</p> <ul><li>Accept</li> <li>Accept-Language</li> <li>Content-Language</li> <li>Content-Type （需要注意额外的限制）</li> <li>DPR</li> <li>Downlink</li> <li>Save-Data</li> <li>Viewport-Width</li> <li>Width</li></ul> <p>情况三：Content-Type的值仅限于下列三者之一：(例如 application/json 为非简单请求)</p> <ul><li>text/plain</li> <li>multipart/form-data</li> <li>application/x-www-form-urlencoded</li></ul> <p>情况四:</p> <p>请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</p> <p>情况五:</p> <p>请求中没有使用 ReadableStream 对象。</p> <ol start="2"><li>非简单请求</li></ol> <p>除以上情况外的。</p> <p>Node中CORS解决代码原生写法</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  ctx<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Origin&quot;</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span>headers<span class="token punctuation">.</span>origin<span class="token punctuation">)</span><span class="token punctuation">;</span>
  ctx<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Credentials&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  ctx<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Request-Method&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;PUT,POST,GET,DELETE,OPTIONS&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  ctx<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>
    <span class="token string">&quot;Access-Control-Allow-Headers&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;Origin, X-Requested-With, Content-Type, Accept, cc&quot;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>method <span class="token operator">===</span> <span class="token string">&quot;OPTIONS&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ctx<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token number">204</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>为了方便可以直接使用中间件<code>koa-cors</code></p> <h4 id="nginx"><a href="#nginx" aria-hidden="true" class="header-anchor">#</a> Nginx</h4> <p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p> <h4 id="postmessage"><a href="#postmessage" aria-hidden="true" class="header-anchor">#</a> postMessage</h4> <p>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p> <h2 id="本地存储"><a href="#本地存储" aria-hidden="true" class="header-anchor">#</a> 本地存储</h2> <h3 id="cookies"><a href="#cookies" aria-hidden="true" class="header-anchor">#</a> cookies</h3> <p>cookie 是指存储在用户本地终端上的数据，同时它是与具体的web页面或者站点相关。cookie数据会自动在web浏览器和web服务器之间传输。</p> <h4 id="特性"><a href="#特性" aria-hidden="true" class="header-anchor">#</a> 特性</h4> <ul><li>不同的浏览器存放的cookie位置不一样</li> <li>cookie的存储是以域名形式区分的，不同的域下存储的cookie是独立</li> <li>可以设置cookie生效的域，也就是说我们能操作的cookie是当前域以及当前域下的子域</li> <li>一个域名下存储的cookie个数是有限的</li> <li>每个cookie存放的内容大小也是有限制的，不同的浏览器存放大小不一样，一般为4KB。</li> <li>cookie也可以设置过期的时间，默认是会话结束的时候，当时间到期自动销毁</li></ul> <h4 id="cookie的增删改"><a href="#cookie的增删改" aria-hidden="true" class="header-anchor">#</a> cookie的增删改</h4> <p><strong>设置</strong></p> <p>cookie的设置可以分为服务端设置和客户端设置</p> <ol><li><strong>服务端设置</strong></li></ol> <p>服务器端响应的response header 中 set-cookie,是服务端专门用来设置cookie的。</p> <p>语法：<code>Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</code></p> <p>注意：</p> <ul><li>一个set-Cookie字段只能设置一个cookie，当你要想设置多个 cookie，需要添加同样多的set-Cookie字段。</li> <li>服务端可以设置cookie 的所有选项：expires、domain、path、secure、HttpOnly</li> <li>通过 Set-Cookie 指定的这些可选项只会在浏览器端使用，而不会被发送至服务器端。</li></ul> <ol start="2"><li><strong>客户端设置</strong></li></ol> <p>语法：<code>document.cookie = &quot;key=value[;expires=date][;domain=domain][;path=path][;secure]&quot;</code></p> <p>注意：客户端可以设置cookie 的下列选项：expires、domain、path、secure（有条件：只有在https协议的网页中，客户端设置secure类型的 cookie 才能成功），但无法设置HttpOnly选项。</p> <p><strong>读取</strong></p> <p>通过document.cookie来获取当前网站下的cookie的时候，得到的字符串形式的值，它包含了当前网站下所有的cookie（为避免跨域脚本(xss)攻击，这个方法只能获取非 HttpOnly 类型的cookie）。它会把所有的cookie通过一个分号+空格的形式串联起来 例如username=xx; age=xxx</p> <p><strong>修改</strong></p> <p>要想修改一个cookie，只需要重新赋值就行，旧的值会被新的值覆盖。但要注意一点，在设置新cookie时，path/domain这几个选项一定要旧cookie 保持一样。否则不会修改旧值，而是添加了一个新的 cookie。</p> <p><strong>删除</strong></p> <p>把要删除的cookie的过期时间设置成已过去的时间,path/domain/这几个选项一定要旧cookie 保持一样。</p> <h4 id="属性"><a href="#属性" aria-hidden="true" class="header-anchor">#</a> 属性</h4> <ol><li>expires</li></ol> <p>用来设置cookie的有效时间，默认为浏览器会话(Session)。</p> <p>时间必须是 GMT 格式的时间；可以通过 new Date().toGMTString()或者new Date().toUTCString() 来获得 。</p> <p>例如<code>expires=Thu, 25 Feb 2020 14:18:00 GMT</code>表示cookie讲在2020年2月25日14:18分之后失效，对于失效的cookie浏览器会清空。</p> <p>注意:</p> <p>expires 是 http/1.0协议中的选项，在新的http/1.1协议中expires已经由 max-age 选项代替，两者的作用都是限制cookie 的有效时间。</p> <p>expires的值是一个时间点（cookie失效时刻= expires），而max-age 的值是一个以秒为单位时间段（cookie失效时刻= 创建时刻+ max-age）。</p> <p>max-age 的默认值是 -1(即有效期为 session )；若max-age有三种可能值：负数、0、正数。负数：有效期session；0：删除cookie；正数：有效期为创建时刻+ max-age</p> <p>假如 Expires 和 Max-Age 都存在，Max-Age 优先级更高。</p> <ol start="2"><li>Domain</li></ol> <p>Domain 指定了 Cookie 可以送达的主机名。假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）。</p> <p>但是很多网址不止有一个域名比如：a.example.com和b.example.com如果他们想要共享cookie那么cookie的domain需要设置为domain=.example.com</p> <p>注意的是不能跨域设置 Cookie</p> <ol start="3"><li>Path</li></ol> <p>Path 指定了一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部。比如设置 Path=/docs，/docs/Web/ 下的资源会带 Cookie 首部，/test 则不会携带 Cookie 首部。</p> <p>Domain 和 Path 标识共同定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。</p> <ol start="4"><li>Secure</li></ol> <p>标记为 Secure 的 Cookie 只应通过被HTTPS协议加密过的请求发送给服务端。使用 HTTPS 安全协议，可以保护 Cookie 在浏览器和 Web 服务器间的传输过程中不被窃取和篡改。</p> <ol start="5"><li>HTTPOnly</li></ol> <p>设置 HTTPOnly 属性可以防止客户端脚本通过 document.cookie 等方式访问 Cookie，有助于避免 XSS 攻击。</p> <ol start="6"><li>SameSite</li></ol> <p>SameSite 是最近非常值得一提的内容，因为 2020年 2 月份发布的 Chrome80 版本中默认屏蔽了第三方的 Cookie。</p> <p>SameSite 属性可以让 Cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。</p> <p>SameSite 可以有下面三种值：</p> <ol><li><strong>Strict</strong> 仅允许一方请求携带Cookie，即浏览器将只发送相同站点请求的Cookie，即当前网页URL与请求目标URL完全一致</li> <li><strong>Lax</strong> 允许部分第三方请求携带Cookie</li> <li><strong>None</strong> 无论是否跨站都会发送Cookie</li></ol> <p>之前默认是None，Chrome80版本后默认是Lax</p> <p>什么是跨站</p> <p>Cookie中的「同站」判断就比较宽松：只要两个 URL 的 eTLD+1 相同即可，不需要考虑协议和端口。</p> <p>其中，eTLD 表示有效顶级域名，注册于 Mozilla 维护的公共后缀列表（Public Suffix List）中，例如，.com、.co.uk、.github.io 等。eTLD+1 则表示，有效顶级域名+二级域名，例如 taobao.com 等。</p> <p>举几个例子，www.taobao.com 和 www.baidu.com 是跨站，www.a.taobao.com 和 www.b.taobao.com 是同站，a.github.io 和 b.github.io 是跨站(注意是跨站)。</p> <p>SameSite 的值从None 变为 Lax 所带来的影响有哪些</p> <table><thead><tr><th style="text-align:center;">请求类型</th> <th style="text-align:center;">实例</th> <th style="text-align:center;">Strict</th> <th style="text-align:center;">Lax</th> <th style="text-align:center;">None</th></tr></thead> <tbody><tr><td style="text-align:center;">链接</td> <td style="text-align:center;"><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td> <td style="text-align:center;">不发送</td> <td style="text-align:center;">发送cookie</td> <td style="text-align:center;">发送cookie</td></tr> <tr><td style="text-align:center;">get表单</td> <td style="text-align:center;"><code>&lt;form method=&quot;GET&quot; action=&quot;&quot;&gt;</code></td> <td style="text-align:center;">不发送</td> <td style="text-align:center;">发送cookie</td> <td style="text-align:center;">发送cookie</td></tr> <tr><td style="text-align:center;">post表单</td> <td style="text-align:center;"><code>&lt;form method=&quot;POST&quot; action=&quot;&quot;&gt;</code></td> <td style="text-align:center;">不发送</td> <td style="text-align:center;">不发送</td> <td style="text-align:center;">发送cookie</td></tr> <tr><td style="text-align:center;">iframe</td> <td style="text-align:center;"><code>&lt;iframe src=&quot;..&quot;&gt;&lt;/iframe&gt;</code></td> <td style="text-align:center;">不发送</td> <td style="text-align:center;">不发送</td> <td style="text-align:center;">发送cookie</td></tr> <tr><td style="text-align:center;">AJAX</td> <td style="text-align:center;"><code>$.get()</code></td> <td style="text-align:center;">不发送</td> <td style="text-align:center;">不发送</td> <td style="text-align:center;">发送cookie</td></tr> <tr><td style="text-align:center;">Image</td> <td style="text-align:center;"><code>&lt;img src=&quot;...&quot;&gt;</code></td> <td style="text-align:center;">不发送</td> <td style="text-align:center;">不发送</td> <td style="text-align:center;">发送cookie</td></tr></tbody></table> <p>从表格中可以看出，对大部分 web 应用而言，Post 表单，iframe，AJAX，Image 这四种情况从以前的跨站会发送三方 Cookie，变成了不发送。</p> <p>Post表单：应该的，学 CSRF 总会举表单的例子。</p> <p>iframe：iframe 嵌入的 web 应用有很多是跨站的，都会受到影响。</p> <p>AJAX：可能会影响部分前端取值的行为和结果。</p> <p>Image：图片一般放 CDN，大部分情况不需要 Cookie，故影响有限。但如果引用了需要鉴权的图片，可能会受到影响</p> <p>不过也会有两点要注意的地方：</p> <ol><li>HTTP 接口不支持 SameSite=none</li></ol> <p>如果你想加 SameSite=none 属性，那么该 Cookie 就必须同时加上 Secure 属性，表示只有在 HTTPS 协议下该 Cookie 才会被发送。</p> <ol start="2"><li>需要 UA 检测，部分浏览器不能加 SameSite=none
IOS 12 的 Safari 以及老版本的一些 Chrome 会把 SameSite=none 识别成 SameSite=Strict，所以服务端必须在下发 Set-Cookie 响应头时进行 User-Agent 检测，对这些浏览器不下发 SameSite=none 属性</li></ol> <h4 id="cookie-的作用与缺点"><a href="#cookie-的作用与缺点" aria-hidden="true" class="header-anchor">#</a> Cookie 的作用与缺点</h4> <p>Cookie 主要用于以下三个方面：</p> <p>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
个性化设置（如用户自定义设置、主题等）
浏览器行为跟踪（如跟踪分析用户行为等）</p> <p>缺点 可以从大小、安全、增加请求大小等方面回答。</p> <h3 id="localstorage、sessionstorage"><a href="#localstorage、sessionstorage" aria-hidden="true" class="header-anchor">#</a> localStorage、sessionStorage</h3> <p>localStorage和sessionStorage都继承于Storage，提供了统一的api来访问和设置数据。API列表:</p> <ul><li>Storage.length 返回一个整数，表示存储在 Storage 对象中的数据项数量。</li> <li>Storage.key() 该方法接受一个数值 n 作为参数，并返回存储中的第 n 个键名。</li> <li>Storage.getItem() 该方法接受一个键名作为参数，返回键名对应的值。</li> <li>Storage.setItem() 该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值</li> <li>Storage.removeItem() 该方法接受一个键名作为参数，并把该键名从存储中删除。</li> <li>Storage.clear() 调用该方法会清空存储中的所有键名。</li></ul> <p>localStorage和sessionStorage不同之处在于 localStorage 里面存储的数据没有过期时间设置，而存储在 sessionStorage 里面的数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话.</p> <h3 id="三者区别"><a href="#三者区别" aria-hidden="true" class="header-anchor">#</a> 三者区别</h3> <p>相同：在本地（浏览器端）存储数据。</p> <p>不同：</p> <ul><li>localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。</li> <li>sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。</li> <li>localStorage是永久存储，除非手动删除。</li> <li>sessionStorage当会话结束（当前页面关闭的时候，自动销毁）</li> <li>cookie的数据会在每一次发送http请求的时候，同时发送给服务器而localStorage、sessionStorage不会。</li></ul> <h3 id="service-worker"><a href="#service-worker" aria-hidden="true" class="header-anchor">#</a> Service Worker</h3> <p>Service worker是一个注册在指定源和路径下的事件驱动worker。它采用JavaScript控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。</p> <p>Service worker运行在worker上下文，因此它不能访问DOM。相对于驱动应用的主JavaScript线程，它运行在其他线程中，所以不会造成阻塞。它设计为完全异步，同步API（如XHR和localStorage）不能在service worker中使用。</p> <p>出于安全考量，Service workers只能由HTTPS承载，毕竟修改网络请求的能力暴露给中间人攻击会非常危险。在Firefox浏览器的用户隐私模式，Service Worker不可用。</p> <h2 id="浏览器安全"><a href="#浏览器安全" aria-hidden="true" class="header-anchor">#</a> 浏览器安全</h2> <h3 id="xss"><a href="#xss" aria-hidden="true" class="header-anchor">#</a> XSS</h3> <p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</p> <p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</p> <h4 id="xss分类"><a href="#xss分类" aria-hidden="true" class="header-anchor">#</a> XSS分类</h4> <p>根据攻击的来源，XSS攻击可以分为存储型、反射型、DOM型三种</p> <table><thead><tr><th style="text-align:left;">类型</th> <th style="text-align:left;">存储区</th> <th style="text-align:left;">插入点</th></tr></thead> <tbody><tr><td style="text-align:left;">存储型 XSS</td> <td style="text-align:left;">后端数据库</td> <td style="text-align:left;">HTML</td></tr> <tr><td style="text-align:left;">反射型 XSS</td> <td style="text-align:left;">URL</td> <td style="text-align:left;">HTML</td></tr> <tr><td style="text-align:left;">DOM 型 XSS</td> <td style="text-align:left;">后端数据库/前端存储/URL</td> <td style="text-align:left;">前端 JavaScript</td></tr></tbody></table> <p>存储区：恶意代码存放的位置。
插入点：由谁取得恶意代码，并插入到网页上。</p> <p><strong>存储型XSS</strong></p> <p>存储型XSS的攻击步骤：</p> <ol><li>攻击者将恶意代码提交都目标网站的数据库中</li> <li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器</li> <li>用户浏览器接收到响应解析执行，混在其中的恶意代码也被执行。</li> <li>恶心代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定操作</li></ol> <p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p> <p><strong>反射型XSS</strong></p> <p>反射型XSS的攻击步骤:</p> <ol><li>攻击者构造出特殊的URL，其中包含恶意代码</li> <li>用户打开带有恶意代码的URL时，网站服务端将恶意代码中URL取出，拼接在HTML中返回给浏览器</li> <li>用户浏览器接收到响应解析执行，混在其中的恶意代码也被执行</li> <li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol> <p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p> <p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</p> <p>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</p> <p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p> <p><strong>DOM型XSS</strong></p> <p>DOM型XSS的攻击步骤:</p> <ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li> <li>用户打开带有恶意代码的 URL。</li> <li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li> <li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol> <p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p> <h4 id="预防xss攻击"><a href="#预防xss攻击" aria-hidden="true" class="header-anchor">#</a> 预防XSS攻击</h4> <p>通过前面的介绍可以得知，XSS 攻击有两大要素：</p> <ul><li>攻击者提交恶意代码。</li> <li>浏览器执行恶意代码。</li></ul> <p><strong>输入过滤</strong></p> <p>针对上述的第一点，我们能够在用户输入的过程中过滤掉用户输入的恶意代码。</p> <p>前端过滤：在用户提交时，由前端过滤输入，然后提交到后端，但是这种方式是有缺陷的，因为攻击者可以绕过前端页面，直接构造请求。</p> <p>后端过滤：后端在将数据写入数据库前过滤，但该方式也有缺陷，不确定输入的内容，在何处被展示，如果展示的地方不同可能会出现不同的结果。</p> <p>所以，输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。</p> <p>当然，对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的</p> <p>既然输入过滤并非完全可靠，我们就要通过“防止浏览器执行恶意代码”来防范 XSS。这部分分为两类：</p> <ul><li>防止 HTML 中出现注入。</li> <li>防止 JavaScript 执行时，执行恶意代码。</li></ul> <p><strong>预防存储型和反射型</strong></p> <p>存储型和反射型XSS都是在服务端取出恶意代码后，插入到响应HTML里的，攻击者刻意编写的&quot;数据&quot;被内嵌到&quot;代码&quot;中，被浏览器执行。</p> <p>预防这两种漏洞，有两种常见做法：</p> <ul><li>改成纯前端渲染，把代码和数据分隔开</li> <li>对HTML做充分转义</li></ul> <p><strong>1. 纯前端渲染</strong></p> <p>纯前端渲染的过程：</p> <ol><li>浏览器先加载一个静态HTML，此HTML中不包含任何跟业务相关的数据</li> <li>然后浏览器执行HTML中的JavaScript</li> <li>JavaScript通过Ajax加载业务数据，调用DOM API更新到页面上</li></ol> <p>在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。
但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 onload 事件和 href 中的 javascript:xxx 等，请参考下文”预防 DOM 型 XSS 攻击“部分）。</p> <p><strong>2. 转义HTML</strong></p> <p>如果拼接HTML是必要的，就需要采用合适的转义库，对HTML中的插入点进行充分的转义</p> <p>对于 HTML 转义通常只有一个规则，就是把 &amp; &lt; &gt; &quot; ' / 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善有些特殊的场景还需要处理</p> <p><strong>预放DOM型XSS攻击</strong></p> <p>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。
在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。</p> <p><strong>其他XSS防范措施</strong></p> <ol><li>Content Security Policy</li></ol> <p>严格的CSP在XSS的防范中可以起到以下的作用</p> <ul><li>禁止加载外域代码，防止复杂的攻击逻辑</li> <li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域</li> <li>禁止内联脚本执行（规则较严格，目前发现Github使用）</li> <li>禁止未授权的脚本执行（Google Map移动版有使用）</li> <li>合理使用上报可以及时发现XSS，利于尽快修复问题</li></ul> <ol start="2"><li>输入内容长度控制</li></ol> <p>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止XSS发生，但可以增加XSS攻击难度</p> <ol start="3"><li>HttpOnly Cookie</li></ol> <p>禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</p> <h3 id="csrf"><a href="#csrf" aria-hidden="true" class="header-anchor">#</a> CSRF</h3> <p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p> <p>一个典型的CSRF攻击有如下的流程：</p> <ol><li>受害者登录A网站，并保留了登录信息（例如cookie）</li> <li>攻击者引诱受害者访问B网站</li> <li>B网站向A网站发送一个请求</li> <li>A接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求</li> <li>A网站一受害者的名义执行了恶意代码</li> <li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让A网站执行了自定义的操作</li></ol> <h4 id="几种常见的攻击类型"><a href="#几种常见的攻击类型" aria-hidden="true" class="header-anchor">#</a> 几种常见的攻击类型</h4> <ol><li><strong>GET类型的CSRF</strong></li></ol> <p>GET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;img src=&quot;http://bank.example/withdraw?amount=10000&amp;for=hacker&quot; &gt; 
</code></pre></div><p>在受害者访问含有这个img的页面后，浏览器会自动向http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。</p> <ol start="2"><li>POST类型的CSRF</li></ol> <p>这种类型的CSRF利用起来通常使用的是一个自动提交的表单，如：</p> <div class="language- extra-class"><pre class="language-text"><code> &lt;form action=&quot;http://bank.example/withdraw&quot; method=POST&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;account&quot; value=&quot;xiaoming&quot; /&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;10000&quot; /&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;for&quot; value=&quot;hacker&quot; /&gt;
&lt;/form&gt;
&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 

</code></pre></div><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。</p> <ol start="3"><li>链接类型的CSRF</li></ol> <p>链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击</p> <h4 id="csrf的特点"><a href="#csrf的特点" aria-hidden="true" class="header-anchor">#</a> CSRF的特点</h4> <ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生</li> <li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作，而不是直接窃取数据</li> <li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是冒用</li> <li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中、难以进行追踪</li></ul> <p>CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。</p> <h4 id="防护策略"><a href="#防护策略" aria-hidden="true" class="header-anchor">#</a> 防护策略</h4> <p>CSRF的两个特点：</p> <ul><li>CSRF 通常发生在第三方域名</li> <li>CSRF 攻击者不能获取到Cookie等信息，只是使用</li></ul> <p>针对该特点，可以指定防护策略。如下：</p> <ol><li>阻止不明外域的访问</li></ol> <ul><li>同源检测</li> <li>Samesite Cookie</li></ul> <ol start="2"><li>提交时要求附加本域才能获取的信息</li></ol> <ul><li>CSRF Token</li> <li>双重Cookie验证</li></ul> <p><strong>同源检测</strong></p> <p>既然CSRF大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。</p> <p>在HTTP协议中，有两个请求头<code>Origin</code>和<code>Referer</code> 用于标记来源域名。</p> <p>这两个Header在浏览器发起时，大多数情况会自动带上，并且不能由前端自定义内容。服务器可以通过解析这两个Header中的域名，确定请求的来源域。</p> <p><strong>Samesite Cookie属性</strong></p> <p>具体可以查看<a href="/browser.html#cookies">Cookie</a>篇</p> <p><strong>CSRF Token</strong></p> <p>该方式的防护策略分为三个步骤:</p> <ol><li>将CSRF Token 输出到页面中</li> <li>页面提交的请求携带这个Token</li> <li>服务器验证Token是否正确</li></ol> <p>这种方法要比之前检查Referer或者Origin要安全一些，Token可以在产生并放于服务端Session之中，然后在每次请求时把Token从Session中拿出，与请求中的Token进行比对，但这种方法的比较麻烦的在于如何把Token以参数的形式加入请求。</p> <p>分布式校验
在大型网站中，使用Session存储CSRF Token会带来很大的压力。访问单台服务器session是同一个。但是现在的大型网站中，我们的服务器通常不止一台，可能是几十台甚至几百台之多，甚至多个机房都可能在不同的省份，用户发起的HTTP请求通常要经过像Ngnix之类的负载均衡器之后，再路由到具体的服务器上，由于Session默认存储在单机服务器内存中，因此在分布式环境下同一个用户发送的多次HTTP请求可能会先后落到不同的服务器上，导致后面发起的HTTP请求无法拿到之前的HTTP请求存储在服务器中的Session数据，从而使得Session机制在分布式环境下失效，因此在分布式集群中CSRF Token需要存储在Redis之类的公共存储空间。
由于使用Session存储，读取和验证CSRF Token会引起比较大的复杂度和性能问题，目前很多网站采用Encrypted Token Pattern方式。这种方法的Token是一个计算出来的结果，而非随机生成的字符串。这样在校验时无需再去读取存储的Token，只用再次计算一次即可。
这种Token的值通常是使用UserID、时间戳和随机数，通过加密的方法生成。这样既可以保证分布式服务的Token一致，又能保证Token不容易被破解。
在token解密成功之后，服务器可以访问解析值，Token中包含的UserID和时间戳将会被拿来被验证有效性，将UserID与当前登录的UserID进行比较，并将时间戳与当前时间进行比较。</p> <p>Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。</p> <p><strong>双重Cookie验证</strong></p> <p>在会话中存储CSRF Token比较繁琐，而且不能在通用的拦截上统一处理所有的接口。</p> <p>那么另一种防御措施是使用双重提交Cookie。利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。</p> <p>双重Cookie采用以下流程：</p> <ol><li>在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。</li> <li>在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。</li> <li>后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。</li></ol> <p>此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。</p> <p>用双重Cookie防御CSRF的优点：</p> <ol><li>无需使用Session，适用面更广，易于实施。</li> <li>Token储存于客户端中，不会给服务器带来压力。</li> <li>相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。</li></ol> <p>缺点：</p> <ol><li>Cookie中增加了额外的字段。</li> <li>如果有其他漏洞（例如XSS），攻击者可以注入Cookie，那么该防御方式失效。</li> <li>难以做到子域名的隔离。</li> <li>为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。</li></ol> <h3 id="jwt"><a href="#jwt" aria-hidden="true" class="header-anchor">#</a> JWT</h3> <p><a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="noopener noreferrer">参考资料<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="sso"><a href="#sso" aria-hidden="true" class="header-anchor">#</a> SSO</h3> <p>单点登录(SingleSignOn，SSO)，就是通过用户的一次性鉴别登录。当用户在身份认证服务器上登录一次以后，即可获得访问单点登录系统中其他关联系统和应用软件的权限，同时这种实现是不需要管理员对用户的登录状态或其他信息进行修改的，这意味着在多个应用系统中，用户只需一次登录就可以访问所有相互信任的应用系统。这种方式减少了由登录产生的时间消耗，辅助了用户管理。</p> <p>当用户第一次访问应用系统1的时候，因为还没有登录，会被引导到认证系统中进行登录；根据用户提供的登录信息，认证系统进行身份校验，如果通过校验，应该返回给用户一个认证的凭据－－ticket；用户再访问别的应用的时候就会将这个ticket带上，作为自己认证的凭据，应用系统接受到请求之后会把ticket送到认证系统进行校验，检查ticket的合法性。如果通过校验，用户就可以在不用再次登录的情况下访问应用系统2和应用系统3了。</p> <h2 id="浏览器缓存"><a href="#浏览器缓存" aria-hidden="true" class="header-anchor">#</a> 浏览器缓存</h2> <p>缓存按缓存策略来分可以分为<strong>强制缓存</strong>和<strong>协商缓存</strong></p> <h3 id="强制缓存"><a href="#强制缓存" aria-hidden="true" class="header-anchor">#</a> 强制缓存</h3> <p>强制缓存直接减少请求数，是提升最大的缓存策略。 如果考虑使用缓存来优化网页性能的话，强制缓存应该是首先被考虑的。可以造成强制缓存的字段是 Cache-control 和 Expires。</p> <h4 id="expires"><a href="#expires" aria-hidden="true" class="header-anchor">#</a> Expires</h4> <p>Expires 是 HTTP 1.0 的字段，表示缓存到期时间。 在Response Headers中，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。例如 Expires: Thu, 10 Nov 2019 08:45:11 GMT</p> <p>但是该字段具有以下缺点：</p> <ul><li>由于服务器返回的时间是绝对时间，用户如果对本地时间进行修改，从而导致浏览器判断缓存失效，重新请求该资源。或者不考虑修改，客户端与服务器端时间可能存在时差或者误差。</li></ul> <h4 id="cache-control"><a href="#cache-control" aria-hidden="true" class="header-anchor">#</a> Cache-control</h4> <p>在HTTP/1.1中，Cache-Control是<strong>最重要</strong>的规则，主要用于控制网页缓存。例如：Cache-control: max-age=60*5。</p> <p>Cache-control 常用字段：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener noreferrer">完整属性列表<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ul><li>max-age 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相比，时间使用的是相对于请求发起的时间。</li> <li>no-cache 在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。</li> <li>no-store 缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。</li> <li>public 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。</li> <li>private 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器。</li> <li>must-revalidate 一旦资源过期（比如已经超过max-</li></ul> <p>这些值可以混合使用。在混合使用时，它们的优先级如下图:</p> <p><img src="https://camo.githubusercontent.com/6d856deffa6c56e887a610ae81e99b50a36172c1/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32362f313637653837333962633732346663623f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" alt=""></p> <p>注意 在 HTTP/1.1 之前，如果想使用 no-cache，通常是使用 Pragma 字段，如 Pragma: no-cache(这也是 Pragma 字段唯一的取值)。</p> <p>自从 HTTP/1.1 开始，Expires 逐渐被 Cache-control 取代。Cache-control 是一个相对时间，即使客户端时间发生改变，相对时间也不会随之改变，这样可以保持服务器和客户端的时间一致性。而且 Cache-control 的可配置性比较强大。</p> <p>Cache-control 的优先级高于 Expires，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段都会设置。</p> <p>如果没有Cache-Contorl和Expires的 header，但有Last-Modified 浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。</p> <h3 id="协商缓存"><a href="#协商缓存" aria-hidden="true" class="header-anchor">#</a> 协商缓存</h3> <p>当强制缓存失效(超过规定时间)时，就需要使用协商缓存，由服务器决定缓存内容是否失效。</p> <p>协商缓存在请求数上和没有缓存是一致的，但如果是 304 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此 在响应体体积上的节省是它的优化点。</p> <p>协商缓存主要通过两组Http Header 值实现 <code>Last-Modified &amp; If-Modified-Since</code> 和 <code>ETag &amp; If-None-Match</code></p> <h4 id="last-modified-if-modified-since"><a href="#last-modified-if-modified-since" aria-hidden="true" class="header-anchor">#</a> Last-Modified &amp; If-Modified-Since</h4> <ol><li><p>服务器端在Response Header 中 <code>Last-Modified</code>字段告知客户端，资源最后一次被修改的时间，例如 <code>Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT</code></p></li> <li><p>下一次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 <code>Last-Modified</code> 的值写入到Request Header的 <code>If-Modified-Since</code> 字段</p></li> <li><p>服务器会将 <code>If-Modified-Since</code> 的值与 <code>Last-Modified</code> 字段进行对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。</p></li></ol> <p><strong>缺点：</strong></p> <ul><li>如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。</li> <li>如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。</li></ul> <h4 id="etag-if-none-match"><a href="#etag-if-none-match" aria-hidden="true" class="header-anchor">#</a> ETag &amp; If-None-Match</h4> <p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。</p> <ol><li><p>服务器端在Response Header 中 <code>ETag</code>字段告知客户端，代表当前资源的唯一标识。</p></li> <li><p>下一次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此将上次的 <code>ETag</code> 的值写入到Request Header的 <code>If-None-Match</code> 字段</p></li> <li><p>服务器会将 <code>If-None-Match</code> 的值与 <code>ETag</code> 字段进行对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。</p></li></ol> <h4 id="last-modified-与-etag-比较"><a href="#last-modified-与-etag-比较" aria-hidden="true" class="header-anchor">#</a> Last-Modified 与 Etag 比较</h4> <ol><li>首先在精确度上，Etag要优于Last-Modified。</li></ol> <p>Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</p> <ol start="2"><li><p>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</p></li> <li><p>第三在优先级上，服务器校验优先考虑Etag</p></li></ol> <h3 id="缓存总结"><a href="#缓存总结" aria-hidden="true" class="header-anchor">#</a> 缓存总结</h3> <p>缓存流程图：</p> <p><img src="/assets/img/cache.2948472e.png" alt=""></p> <h4 id="用户行为对缓存的影响"><a href="#用户行为对缓存的影响" aria-hidden="true" class="header-anchor">#</a> 用户行为对缓存的影响</h4> <table><thead><tr><th style="text-align:center;">用户操作</th> <th style="text-align:center;">Expries/Cache-Control</th> <th style="text-align:center;">Last-Modied/Etag</th></tr></thead> <tbody><tr><td style="text-align:center;">地址栏回车</td> <td style="text-align:center;">有效</td> <td style="text-align:center;">有效</td></tr> <tr><td style="text-align:center;">页面链接跳转</td> <td style="text-align:center;">有效</td> <td style="text-align:center;">有效</td></tr> <tr><td style="text-align:center;">新开窗口</td> <td style="text-align:center;">有效</td> <td style="text-align:center;">有效</td></tr> <tr><td style="text-align:center;">浏览器前进后退</td> <td style="text-align:center;">有效</td> <td style="text-align:center;">有效</td></tr> <tr><td style="text-align:center;">F5刷新</td> <td style="text-align:center;">无效</td> <td style="text-align:center;">有效</td></tr> <tr><td style="text-align:center;">ctrl + F5 强制刷新</td> <td style="text-align:center;">无效</td> <td style="text-align:center;">无效</td></tr></tbody></table> <h3 id="实际项目中的缓存问题"><a href="#实际项目中的缓存问题" aria-hidden="true" class="header-anchor">#</a> 实际项目中的缓存问题</h3> <h4 id="微信浏览器h5页面缓存问题"><a href="#微信浏览器h5页面缓存问题" aria-hidden="true" class="header-anchor">#</a> 微信浏览器H5页面缓存问题</h4> <p>问题描述：在微信公众号中添加h5跳转链接，当项目更新发布之后，在微信公众号中点击入口进入，页面出现白屏。</p> <p>问题定位：跟过调试和分析发现是微信浏览器缓存问题，更新发布现代码之后，调用的还是上一次的js 资源</p> <p>h5页面技术实现：react</p> <p>问题解决：</p> <ol><li>app.js 添加 时间戳后缀</li> <li>index.html 文件中添加</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code> <span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">&quot;Cache-Control&quot;</span> content<span class="token operator">=</span><span class="token string">&quot;no-cache, no-store, must-revalidate&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">&quot;Pragma&quot;</span> content<span class="token operator">=</span><span class="token string">&quot;no-cache&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">&quot;Expires&quot;</span> content<span class="token operator">=</span><span class="token string">&quot;0&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre></div><ol start="3"><li>nginx 配置中添加</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code>location <span class="token operator">/</span> <span class="token punctuation">{</span>
    root   html<span class="token punctuation">;</span>
    index  index<span class="token punctuation">.</span>html<span class="token punctuation">;</span>
    add_header Cache<span class="token operator">-</span>Control no<span class="token operator">-</span>cache<span class="token punctuation">;</span> <span class="token comment">// 主要是这一行 忽略缓存</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="chrome-devtools"><a href="#chrome-devtools" aria-hidden="true" class="header-anchor">#</a> Chrome DevTools</h2> <p>Chrome DevTools是前端开发最主要的调试工具,但普遍许多同学只使用了其中一部分功能。常用的为下图红框内。 目前Chrome最新版本 V81。</p> <p><img src="/assets/img/chrome.8492c2e7.png" alt=""></p> <p>那么接下来我们详细的了解下Chrome DevTools的各个功能。</p> <h3 id="elements"><a href="#elements" aria-hidden="true" class="header-anchor">#</a> Elements</h3> <p>使用Chrome DevTools Elements(元素)面板，检查并实时编辑页面中的HTML和CSS。</p> <ol><li><p>在Elements(元素)面板中随时检查并编辑 DOM 树中的任何元素。</p></li> <li><p>在Styles(样式)窗格中查看和更改应用于任何选定元素的CSS规则。</p></li> <li><p>在Computed(计算)窗格中查看和编辑所选元素的盒模型。</p></li></ol> <h3 id="console"><a href="#console" aria-hidden="true" class="header-anchor">#</a> Console</h3> <p>想必很了解 就不阐述了</p> <h3 id="sources"><a href="#sources" aria-hidden="true" class="header-anchor">#</a> Sources</h3> <p>可以查看加载的js 代码  进行断点调试</p> <h3 id="netwrok"><a href="#netwrok" aria-hidden="true" class="header-anchor">#</a> Netwrok</h3> <p>Network(网络)面板记录在页面上有关每个网络操作的信息，包括详细的时序数据，HTTP请求和响应头，Cookie等。</p> <p>Network(网络)面板可分为5个窗格：</p> <p><img src="/assets/img/network.4466ace0.png" alt=""></p> <ol><li>Controls(控件): 使用这些选项可以控制 Network(网络)面板的外观和功能。</li> <li>Filters(过滤器): 使用这些选项可以控制在请求列表中显示哪些资源。提示：按住Cmd（Mac）或Ctrl（Window / Linux），然后点击过滤器可以同时选择多个过滤器。</li> <li>Overview(概览): 这个图表显示检索资源的时间轴。如果您看到多个垂直堆叠的栏，这意味着这些资源被同时检索。</li> <li>Requests Table(请求列表): 此列表列出了检索的每个资源。默认情况下，此表按时间顺序排序，也就是最早的资源在顶部。单击资源名称可以获得更多信息。提示：右键单击列表的任何标题栏可以以添加或删除信息列。</li> <li>Summary(概要): 概要窗格告诉您请求的总数，传输的数据量，和加载时间。</li></ol> <p><strong>请求列表</strong></p> <ul><li>Name(名称) : 资源的名称。</li> <li>Status(状态) :  HTTP状态代码。</li> <li>Type(类型) : 请求的资源的MIME类型。
<ul><li>Initiator(发起人) : 发起请求的对象或进程。它可能有以下几种值：</li> <li>Parser(解析器) :  Chrome的HTML解析器发起了请求。</li> <li>Redirect(重定向) :  HTTP重定向启动了请求。</li> <li>Script(脚本) : 脚本启动了请求。</li> <li>Other(其他) : 一些其他进程或动作发起请求，例如用户点击链接跳转到页面，或在地址栏中输入网址。</li></ul></li> <li>Size(尺寸) : 响应头的大小（通常是几百字节）加上响应数据，由服务器提供。</li> <li>Time(时间) : 总持续时间，从请求的开始到接收响应中的最后一个字节。</li> <li>Timeline(时间轴) :  Timeline列显示所有网络请求的视觉瀑布。点击此列的标题栏会显示其他排序字段的菜单。</li></ul> <p><strong>查看DOMContentLoaded和load事件信息</strong></p> <p>当页面的初始的标记被解析完时，会触发DOMContentLoaded。 它在Network(网络)面板上的两个位置显示：</p> <ol><li>在Overview(概览)窗格中的蓝色垂直线表示这个事件。</li> <li>在Summary(概要)窗格中，您可以查看事件的确切时间。</li></ol> <p>当页面完全加载时触发load事件。 它显示在：</p> <ol><li>在Overview(概览)窗格的红色垂直线表示这个事件。</li> <li>在Summary(概要)中，您可以查看改事件的确切时间。</li></ol> <p><img src="/assets/img/load.3da857e5.png" alt=""></p> <p><strong>查看单个资源的详细信息</strong></p> <p>点击资源名称（在Requests Table(请求列表)的Name(名称)列中）可以查看该资源的更多信息。</p> <p>可用的标签页取决于您选择的资源类型，但以下四个标签页是最常见的：</p> <ul><li>Headers(标头) : 与资源相关的HTTP头。</li> <li>Preview(预览) : 预览JSON，图片和文字资源。</li> <li>Response(响应) : HTTP响应数据（如果有）。</li> <li>Timing(时序) : 资源的请求生命周期的明细分类。</li></ul> <p>点击Timing(时序)选项卡可查看单个资源的请求生命周期的明细分类。</p> <p>生命周期显示在以下类别中花费的时间：</p> <ul><li>Queuing(排队)</li> <li>Stalled(停滞) 如果适用：DNS lookup(DNS查找)， initial connection(初始连接)， SSL handshake(SSL握手)</li> <li>Request sent(请求发送)</li> <li>Waiting(等待)（到开始下载第一个字节的时间（TTFB））</li> <li>Content Download(内容下载)</li></ul> <h3 id="performance"><a href="#performance" aria-hidden="true" class="header-anchor">#</a> Performance</h3> <p><img src="/assets/img/performance.b6bc923c.jpg" alt=""></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/es6.html" class="prev">
          ES6
        </a></span> <span class="next"><a href="/network.html">
          网络
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.94b2f3ef.js" defer></script><script src="/assets/js/2.d467c8ee.js" defer></script><script src="/assets/js/5.d198a837.js" defer></script>
  </body>
</html>
